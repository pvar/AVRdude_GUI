<?xml version="1.0"?>
<AVRPART>
  <MODULE_LIST>[ADMIN:CORE:FUSE:INTERRUPT_VECTOR:MEMORY:PACKAGE:PROGRAMMING:LOCKBIT:IO_MODULE:ICE_SETTINGS]</MODULE_LIST>
  <ADMIN>
    <PART_NAME>ATA6289</PART_NAME>
    <SPEED>4MHZ</SPEED>
    <BUILD>1</BUILD>
    <RELEASE_STATUS>RELEASED</RELEASE_STATUS>
    <SIGNATURE>
      <ADDR000>$1E</ADDR000>
      <ADDR001>$93</ADDR001>
      <ADDR002>$82</ADDR002>
    </SIGNATURE>
  </ADMIN>
  <CORE>
    <CORE_VERSION>V2E</CORE_VERSION>
    <ID>AVRSimCoreV2.SimCoreV2</ID>
    <NEW_INSTRUCTIONS>[]</NEW_INSTRUCTIONS>
    <INSTRUCTIONS_NOT_SUPPORTED>[]</INSTRUCTIONS_NOT_SUPPORTED>
    <RAMP_REGISTERS>[]</RAMP_REGISTERS>
    <GP_REG_FILE>
      <NMB_REG>32</NMB_REG>
      <START_ADDR>$00</START_ADDR>
      <X_REG_HIGH>$1B</X_REG_HIGH>
      <X_REG_LOW>$1A</X_REG_LOW>
      <Y_REG_HIGH>$1D</Y_REG_HIGH>
      <Y_REG_LOW>$1C</Y_REG_LOW>
      <Z_REG_HIGH>$1F</Z_REG_HIGH>
      <Z_REG_LOW>$1E</Z_REG_LOW>
    </GP_REG_FILE>
  </CORE>
  <FUSE>
    <LIST>[LOW:HIGH]</LIST>
    <ID/>
    <ICON/>
    <TEXT/>
    <LOW>
      <NMB_FUSE_BITS>8</NMB_FUSE_BITS>
      <FUSE7>
        <NAME>CKDIV8</NAME>
        <TEXT>Divide clock by 8</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE7>
      <FUSE6>
        <NAME>CKOUT</NAME>
        <TEXT>Clock output</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE6>
      <FUSE5>
        <NAME>SUT1</NAME>
        <TEXT>Select start-up time</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE5>
      <FUSE4>
        <NAME>SUT0</NAME>
        <TEXT>Select start-up time</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE4>
      <FUSE3>
        <NAME>WDRCON</NAME>
        <TEXT>Enable Watchdog RC-Oscillator</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE3>
      <FUSE2>
        <NAME>FRCFS</NAME>
        <TEXT>Fast RC-Oscillator Frequency select</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE2>
      <FUSE1>
        <NAME>BODEN</NAME>
        <TEXT>Enable Brown-out detection</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>TSRDI</NAME>
        <TEXT>Disable Temperatur shutdown Reset </TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <NMB_TEXT>10</NMB_TEXT>
      <TEXT1>
        <MASK>0x80</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Divide clock by 8 internally; [CKDIV8=0]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x40</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Clock output on PORTC1; [CKOUT=0]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x30</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms;   [SUT=00]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x30</MASK>
        <VALUE>0x10</VALUE>
        <TEXT>Start-up time PWRDWN/RESET: 6 CK/14 CK + 5.7 ms; [SUT=01]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x30</MASK>
        <VALUE>0x20</VALUE>
        <TEXT>Start-up time PWRDWN/RESET: 6 CK/14 CK + 90 ms;  [SUT=10]</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x30</MASK>
        <VALUE>0x30</VALUE>
        <TEXT>Reserved [SUT=11]</TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0x08</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Enable Watchdog RC-Oscillator</TEXT>
      </TEXT7>
      <TEXT8>
        <MASK>0x04</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Run fast RC-oscillator at 4 MHz [FRCFS=0]</TEXT>
      </TEXT8>
      <TEXT9>
        <MASK>0x02</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Enable Brown-Out detection [BODEN=0]</TEXT>
      </TEXT9>
      <TEXT10>
        <MASK>0x01</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Disable Temperatur shutdown Reset </TEXT>
      </TEXT10>
    </LOW>
    <HIGH>
      <NMB_FUSE_BITS>8</NMB_FUSE_BITS>
      <FUSE7>
        <NAME>EELOCK</NAME>
        <TEXT>Upper EEPROM Locked (disabled)</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE7>
      <FUSE6>
        <NAME>DWEN</NAME>
        <TEXT>debugWIRE Enable</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE6>
      <FUSE5>
        <NAME>SPIEN</NAME>
        <TEXT>Enable Serial programming and Data Downloading</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE5>
      <FUSE4>
        <NAME>WDTON</NAME>
        <TEXT>Watchdog Timer Always On</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE4>
      <FUSE3>
        <NAME>EESAVE</NAME>
        <TEXT>EEPROM memory is preserved through chip erase</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE3>
      <FUSE2>
        <NAME>BOOTSZ1</NAME>
        <TEXT>Boot size select</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE2>
      <FUSE1>
        <NAME>BOOTSZ0</NAME>
        <TEXT>Boot size select</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>BOOTRST</NAME>
        <TEXT>Select reset vector</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <NMB_TEXT>10</NMB_TEXT>
      <TEXT1>
        <MASK>0x80</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Upper EEPROM Locked (disabled)</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x40</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Debug Wire enable; [DWEN=0]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x20</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Serial program downloading (SPI) enabled; [SPIEN=0]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x10</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Watch-dog Timer always on; [WDTON=0]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x08</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Preserve EEPROM memory through the Chip Erase cycle; [EESAVE=0]</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x06</MASK>
        <VALUE>0x06</VALUE>
        <TEXT>Boot size = 128 words</TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0x06</MASK>
        <VALUE>0x04</VALUE>
        <TEXT>Boot size = 256 words</TEXT>
      </TEXT7>
      <TEXT8>
        <MASK>0x06</MASK>
        <VALUE>0x02</VALUE>
        <TEXT>Boot size = 512 words</TEXT>
      </TEXT8>
      <TEXT9>
        <MASK>0x06</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Boot size = 1024 words</TEXT>
      </TEXT9>
      <TEXT10>
        <MASK>0x01</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Enable application program reset address vector</TEXT>
      </TEXT10>
    </HIGH>
  </FUSE>
  <INTERRUPT_VECTOR>
    <NMB_VECTORS>27</NMB_VECTORS>
    <ID>AVRSimInterrupt.SimInterrupt</ID>
    <VECTOR1>
      <PROGRAM_ADDRESS>$000</PROGRAM_ADDRESS>
      <SOURCE>RESET</SOURCE>
      <DEFINITION>External Pin, Power-on Reset, Brown-out Reset, Watchdog Reset and Temperature Shutdown Reset</DEFINITION>
    </VECTOR1>
    <VECTOR2>
      <PROGRAM_ADDRESS>$001</PROGRAM_ADDRESS>
      <SOURCE>INT0</SOURCE>
      <DEFINITION>External Interrupt Request 0</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR2>
    <VECTOR3>
      <PROGRAM_ADDRESS>$002</PROGRAM_ADDRESS>
      <SOURCE>INT1</SOURCE>
      <DEFINITION>External Interrupt Request 1</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR3>
    <VECTOR4>
      <PROGRAM_ADDRESS>$003</PROGRAM_ADDRESS>
      <SOURCE>PCINT0</SOURCE>
      <DEFINITION>Pin Change Interrupt Request 0</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR4>
    <VECTOR5>
      <PROGRAM_ADDRESS>$004</PROGRAM_ADDRESS>
      <SOURCE>PCINT1</SOURCE>
      <DEFINITION>Pin Change Interrupt Request 1</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR5>
    <VECTOR6>
      <PROGRAM_ADDRESS>$005</PROGRAM_ADDRESS>
      <SOURCE>PCINT2</SOURCE>
      <DEFINITION>Pin Change Interrupt Request 2</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR6>
    <VECTOR7>
      <PROGRAM_ADDRESS>$006</PROGRAM_ADDRESS>
      <SOURCE>INTVM</SOURCE>
      <DEFINITION>Voltage Monitor Interrupt</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR7>
    <VECTOR8>
      <PROGRAM_ADDRESS>$007</PROGRAM_ADDRESS>
      <SOURCE>SENINT</SOURCE>
      <DEFINITION>Sensor Interface Interrupt</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR8>
    <VECTOR9>
      <PROGRAM_ADDRESS>$008</PROGRAM_ADDRESS>
      <SOURCE>INTT0</SOURCE>
      <DEFINITION>Timer0 Interval Interrupt</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR9>
    <VECTOR10>
      <PROGRAM_ADDRESS>$009</PROGRAM_ADDRESS>
      <SOURCE>LFWP</SOURCE>
      <DEFINITION>LF-Receiver Wake-up Interrupt</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR10>
    <VECTOR11>
      <PROGRAM_ADDRESS>$00A</PROGRAM_ADDRESS>
      <SOURCE>T3CAP</SOURCE>
      <DEFINITION>Timer/Counter3 Capture Event</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR11>
    <VECTOR12>
      <PROGRAM_ADDRESS>$00B</PROGRAM_ADDRESS>
      <SOURCE>T3COMA</SOURCE>
      <DEFINITION>Timer/Counter3 Compare Match A</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR12>
    <VECTOR13>
      <PROGRAM_ADDRESS>$00C</PROGRAM_ADDRESS>
      <SOURCE>T3COMB</SOURCE>
      <DEFINITION>Timer/Counter3 Compare Match B</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR13>
    <VECTOR14>
      <PROGRAM_ADDRESS>$00D</PROGRAM_ADDRESS>
      <SOURCE>T3OVF</SOURCE>
      <DEFINITION>Timer/Counter3 Overflow</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR14>
    <VECTOR15>
      <PROGRAM_ADDRESS>$00E</PROGRAM_ADDRESS>
      <SOURCE>T2CAP</SOURCE>
      <DEFINITION>Timer/Counter2 Capture Event</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR15>
    <VECTOR16>
      <PROGRAM_ADDRESS>$00F</PROGRAM_ADDRESS>
      <SOURCE>T2COM</SOURCE>
      <DEFINITION>Timer/Counter2 Compare Match</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR16>
    <VECTOR17>
      <PROGRAM_ADDRESS>$010</PROGRAM_ADDRESS>
      <SOURCE>T2OVF</SOURCE>
      <DEFINITION>Timer/Counter2 Overflow</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR17>
    <VECTOR18>
      <PROGRAM_ADDRESS>$011</PROGRAM_ADDRESS>
      <SOURCE>SPISTC</SOURCE>
      <DEFINITION>SPI Serial Transfer Complete</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR18>
    <VECTOR19>
      <PROGRAM_ADDRESS>$012</PROGRAM_ADDRESS>
      <SOURCE>LFRXB</SOURCE>
      <DEFINITION>LF Receive Buffer Interrupt</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR19>
    <VECTOR20>
      <PROGRAM_ADDRESS>$013</PROGRAM_ADDRESS>
      <SOURCE>INTT1</SOURCE>
      <DEFINITION>Timer1 Interval Interrupt</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR20>
    <VECTOR21>
      <PROGRAM_ADDRESS>$014</PROGRAM_ADDRESS>
      <SOURCE>T2RXB</SOURCE>
      <DEFINITION>Timer2 SSI Receive Buffer Interrupt</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR21>
    <VECTOR22>
      <PROGRAM_ADDRESS>$015</PROGRAM_ADDRESS>
      <SOURCE>T2TXB</SOURCE>
      <DEFINITION>Timer2 SSI Transmit Buffer Interrupt</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR22>
    <VECTOR23>
      <PROGRAM_ADDRESS>$016</PROGRAM_ADDRESS>
      <SOURCE>T2TXC</SOURCE>
      <DEFINITION>Timer2 SSI Transmit Complete Interrupt</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR23>
    <VECTOR24>
      <PROGRAM_ADDRESS>$017</PROGRAM_ADDRESS>
      <SOURCE>LFREOB</SOURCE>
      <DEFINITION>LF-Receiver End of Burst Interrupt</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR24>
    <VECTOR25>
      <PROGRAM_ADDRESS>$018</PROGRAM_ADDRESS>
      <SOURCE>EXCM</SOURCE>
      <DEFINITION>External Input Clock break down Interrupt</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR25>
    <VECTOR26>
      <PROGRAM_ADDRESS>$019</PROGRAM_ADDRESS>
      <SOURCE>EEREADY</SOURCE>
      <DEFINITION>EEPROM Ready Interrupt</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR26>
    <VECTOR27>
      <PROGRAM_ADDRESS>$01A</PROGRAM_ADDRESS>
      <SOURCE>SPM_RDY</SOURCE>
      <DEFINITION>Store Program Memory Ready</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR27>
  </INTERRUPT_VECTOR>
  <MEMORY>
    <ID>AVRSimMemory8bit.SimMemory8bit</ID>
    <PROG_FLASH>8192</PROG_FLASH>
    <EEPROM>320</EEPROM>
    <INT_SRAM>
      <SIZE>512</SIZE>
      <START_ADDR>$100</START_ADDR>
    </INT_SRAM>
    <EXT_SRAM>
      <SIZE>0</SIZE>
      <START_ADDR>NA</START_ADDR>
    </EXT_SRAM>
    <IO_MEMORY>
      <IO_START_ADDR>$00</IO_START_ADDR>
      <IO_STOP_ADDR>$3F</IO_STOP_ADDR>
      <EXT_IO_START_ADDR>$60</EXT_IO_START_ADDR>
      <EXT_IO_STOP_ADDR>$FF</EXT_IO_STOP_ADDR>
      <MEM_START_ADDR>$20</MEM_START_ADDR>
      <MEM_STOP_ADDR>$FF</MEM_STOP_ADDR>
      <LFCALH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x87</MEM_ADDR>
        <LFCAL_08_MASK>0x01</LFCAL_08_MASK>
        <LFCAL_09_MASK>0x02</LFCAL_09_MASK>
        <LFCAL_10_MASK>0x04</LFCAL_10_MASK>
        <LFCAL_11_MASK>0x08</LFCAL_11_MASK>
        <LFCAL_12_MASK>0x10</LFCAL_12_MASK>
        <LFCAL_13_MASK>0x20</LFCAL_13_MASK>
        <LFCAL_14_MASK>0x40</LFCAL_14_MASK>
        <LFCAL_15_MASK>0x80</LFCAL_15_MASK>
      </LFCALH>
      <LFCALL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x86</MEM_ADDR>
        <LFCAL_00_MASK>0x01</LFCAL_00_MASK>
        <LFCAL_01_MASK>0x02</LFCAL_01_MASK>
        <LFCAL_02_MASK>0x04</LFCAL_02_MASK>
        <LFCAL_03_MASK>0x08</LFCAL_03_MASK>
        <LFCAL_04_MASK>0x10</LFCAL_04_MASK>
        <LFCAL_05_MASK>0x20</LFCAL_05_MASK>
        <LFCAL_06_MASK>0x40</LFCAL_06_MASK>
        <LFCAL_07_MASK>0x80</LFCAL_07_MASK>
      </LFCALL>
      <LFIDCH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x85</MEM_ADDR>
        <LFIDCH_8_MASK>0x01</LFIDCH_8_MASK>
        <LFIDCH_9_MASK>0x02</LFIDCH_9_MASK>
        <LFIDCH_10_MASK>0x04</LFIDCH_10_MASK>
        <LFIDCH_11_MASK>0x08</LFIDCH_11_MASK>
        <LFIDCH_12_MASK>0x10</LFIDCH_12_MASK>
        <LFIDCH_13_MASK>0x20</LFIDCH_13_MASK>
        <LFIDCH_14_MASK>0x40</LFIDCH_14_MASK>
        <LFIDCH_15_MASK>0x80</LFIDCH_15_MASK>
      </LFIDCH>
      <LFIDCL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x84</MEM_ADDR>
        <LFIDCL_0_MASK>0x01</LFIDCL_0_MASK>
        <LFIDCL_1_MASK>0x02</LFIDCL_1_MASK>
        <LFIDCL_2_MASK>0x04</LFIDCL_2_MASK>
        <LFIDCL_3_MASK>0x08</LFIDCL_3_MASK>
        <LFIDCL_4_MASK>0x10</LFIDCL_4_MASK>
        <LFIDCL_5_MASK>0x20</LFIDCL_5_MASK>
        <LFIDCL_6_MASK>0x40</LFIDCL_6_MASK>
        <LFIDCL_7_MASK>0x80</LFIDCL_7_MASK>
      </LFIDCL>
      <LFHCR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x83</MEM_ADDR>
        <LFHCR0_MASK>0x01</LFHCR0_MASK>
        <LFHCR1_MASK>0x02</LFHCR1_MASK>
        <LFHCR2_MASK>0x04</LFHCR2_MASK>
        <LFHCR3_MASK>0x08</LFHCR3_MASK>
        <LFHCR4_MASK>0x10</LFHCR4_MASK>
        <LFHCR5_MASK>0x20</LFHCR5_MASK>
        <LFHCR6_MASK>0x40</LFHCR6_MASK>
      </LFHCR>
      <LFRCR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x82</MEM_ADDR>
        <LFEN_MASK>0x01</LFEN_MASK>
        <LFBM_MASK>0x02</LFBM_MASK>
        <LFWM0_MASK>0x04</LFWM0_MASK>
        <LFWM1_MASK>0x08</LFWM1_MASK>
        <LFRSS_MASK>0x10</LFRSS_MASK>
        <LFCS0_MASK>0x20</LFCS0_MASK>
        <LFCS1_MASK>0x40</LFCS1_MASK>
        <LFCS2_MASK>0x80</LFCS2_MASK>
      </LFRCR>
      <LFIMR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x81</MEM_ADDR>
        <LFWIM_MASK>0x01</LFWIM_MASK>
        <LFBIM_MASK>0x02</LFBIM_MASK>
        <LFEIM_MASK>0x04</LFEIM_MASK>
      </LFIMR>
      <T3IMR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7F</MEM_ADDR>
        <T3OIM_MASK>0x01</T3OIM_MASK>
        <T3CAIM_MASK>0x02</T3CAIM_MASK>
        <T3CBIM_MASK>0x04</T3CBIM_MASK>
        <T3CPIM_MASK>0x08</T3CPIM_MASK>
      </T3IMR>
      <T3CRB>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7E</MEM_ADDR>
        <T3CTMA_MASK>0x01</T3CTMA_MASK>
        <T3SAMA_MASK>0x02</T3SAMA_MASK>
        <T3CRMA_MASK>0x04</T3CRMA_MASK>
        <T3CTMB_MASK>0x08</T3CTMB_MASK>
        <T3SAMB_MASK>0x10</T3SAMB_MASK>
        <T3CRMB_MASK>0x20</T3CRMB_MASK>
        <T3CPRM_MASK>0x40</T3CPRM_MASK>
      </T3CRB>
      <T3MRB>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7D</MEM_ADDR>
        <T3M0_MASK>0x01</T3M0_MASK>
        <T3M1_MASK>0x02</T3M1_MASK>
        <T3M2_MASK>0x04</T3M2_MASK>
        <T3TOP_MASK>0x10</T3TOP_MASK>
      </T3MRB>
      <T3MRA>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7C</MEM_ADDR>
        <T3CS0_MASK>0x01</T3CS0_MASK>
        <T3CS1_MASK>0x02</T3CS1_MASK>
        <T3CS2_MASK>0x04</T3CS2_MASK>
        <T3CE0_MASK>0x08</T3CE0_MASK>
        <T3CE1_MASK>0x10</T3CE1_MASK>
        <T3CNC_MASK>0x20</T3CNC_MASK>
        <T3ICS0_MASK>0x40</T3ICS0_MASK>
        <T3ICS1_MASK>0x80</T3ICS1_MASK>
      </T3MRA>
      <T3CORBH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7B</MEM_ADDR>
        <T3CORBH0_MASK>0x01</T3CORBH0_MASK>
        <T3CORBH1_MASK>0x02</T3CORBH1_MASK>
        <T3CORBH2_MASK>0x04</T3CORBH2_MASK>
        <T3CORBH3_MASK>0x08</T3CORBH3_MASK>
        <T3CORBH4_MASK>0x10</T3CORBH4_MASK>
        <T3CORBH5_MASK>0x20</T3CORBH5_MASK>
        <T3CORBH6_MASK>0x40</T3CORBH6_MASK>
        <T3CORBH7_MASK>0x80</T3CORBH7_MASK>
      </T3CORBH>
      <T3CORBL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7A</MEM_ADDR>
        <T3CORBL0_MASK>0x01</T3CORBL0_MASK>
        <T3CORBL1_MASK>0x02</T3CORBL1_MASK>
        <T3CORBL2_MASK>0x04</T3CORBL2_MASK>
        <T3CORBL3_MASK>0x08</T3CORBL3_MASK>
        <T3CORBL4_MASK>0x10</T3CORBL4_MASK>
        <T3CORBL5_MASK>0x20</T3CORBL5_MASK>
        <T3CORBL6_MASK>0x40</T3CORBL6_MASK>
        <T3CORBL7_MASK>0x80</T3CORBL7_MASK>
      </T3CORBL>
      <T3CORAH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x79</MEM_ADDR>
        <T3CORAH0_MASK>0x01</T3CORAH0_MASK>
        <T3CORAH1_MASK>0x02</T3CORAH1_MASK>
        <T3CORAH2_MASK>0x04</T3CORAH2_MASK>
        <T3CORAH3_MASK>0x08</T3CORAH3_MASK>
        <T3CORAH4_MASK>0x10</T3CORAH4_MASK>
        <T3CORAH5_MASK>0x20</T3CORAH5_MASK>
        <T3CORAH6_MASK>0x40</T3CORAH6_MASK>
        <T3CORAH7_MASK>0x80</T3CORAH7_MASK>
      </T3CORAH>
      <T3CORAL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x78</MEM_ADDR>
        <T3CORAL0_MASK>0x01</T3CORAL0_MASK>
        <T3CORAL1_MASK>0x02</T3CORAL1_MASK>
        <T3CORAL2_MASK>0x04</T3CORAL2_MASK>
        <T3CORAL3_MASK>0x08</T3CORAL3_MASK>
        <T3CORAL4_MASK>0x10</T3CORAL4_MASK>
        <T3CORAL5_MASK>0x20</T3CORAL5_MASK>
        <T3CORAL6_MASK>0x40</T3CORAL6_MASK>
        <T3CORAL7_MASK>0x80</T3CORAL7_MASK>
      </T3CORAL>
      <T3ICRH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x77</MEM_ADDR>
        <T3ICRH0_MASK>0x01</T3ICRH0_MASK>
        <T3ICRH1_MASK>0x02</T3ICRH1_MASK>
        <T3ICRH2_MASK>0x04</T3ICRH2_MASK>
        <T3ICRH3_MASK>0x08</T3ICRH3_MASK>
        <T3ICRH4_MASK>0x10</T3ICRH4_MASK>
        <T3ICRH5_MASK>0x20</T3ICRH5_MASK>
        <T3ICRH6_MASK>0x40</T3ICRH6_MASK>
        <T3ICRH7_MASK>0x80</T3ICRH7_MASK>
      </T3ICRH>
      <T3ICRL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x76</MEM_ADDR>
        <T3ICRL0_MASK>0x01</T3ICRL0_MASK>
        <T3ICRL1_MASK>0x02</T3ICRL1_MASK>
        <T3ICRL2_MASK>0x04</T3ICRL2_MASK>
        <T3ICRL3_MASK>0x08</T3ICRL3_MASK>
        <T3ICRL4_MASK>0x10</T3ICRL4_MASK>
        <T3ICRL5_MASK>0x20</T3ICRL5_MASK>
        <T3ICRL6_MASK>0x40</T3ICRL6_MASK>
        <T3ICRL7_MASK>0x80</T3ICRL7_MASK>
      </T3ICRL>
      <T2IMR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x74</MEM_ADDR>
        <T2OIM_MASK>0x01</T2OIM_MASK>
        <T2CIM_MASK>0x02</T2CIM_MASK>
        <T2CPIM_MASK>0x04</T2CPIM_MASK>
        <T2RXIM_MASK>0x08</T2RXIM_MASK>
        <T2TXIM_MASK>0x10</T2TXIM_MASK>
        <T2TCIM_MASK>0x20</T2TCIM_MASK>
      </T2IMR>
      <T2MRB>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x73</MEM_ADDR>
        <T2M0_MASK>0x01</T2M0_MASK>
        <T2M1_MASK>0x02</T2M1_MASK>
        <T2M2_MASK>0x04</T2M2_MASK>
        <T2M3_MASK>0x08</T2M3_MASK>
        <T2TOP_MASK>0x10</T2TOP_MASK>
        <T2CPOL_MASK>0x40</T2CPOL_MASK>
        <T2SSIE_MASK>0x80</T2SSIE_MASK>
      </T2MRB>
      <T2MRA>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x72</MEM_ADDR>
        <T2CS0_MASK>0x01</T2CS0_MASK>
        <T2CS1_MASK>0x02</T2CS1_MASK>
        <T2CS2_MASK>0x04</T2CS2_MASK>
        <T2CE0_MASK>0x08</T2CE0_MASK>
        <T2CE1_MASK>0x10</T2CE1_MASK>
        <T2CNC_MASK>0x20</T2CNC_MASK>
        <T2TP0_MASK>0x40</T2TP0_MASK>
        <T2TP1_MASK>0x80</T2TP1_MASK>
      </T2MRA>
      <T2CORH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x71</MEM_ADDR>
        <T2CORH0_MASK>0x01</T2CORH0_MASK>
        <T2CORH1_MASK>0x02</T2CORH1_MASK>
        <T2CORH2_MASK>0x04</T2CORH2_MASK>
        <T2CORH3_MASK>0x08</T2CORH3_MASK>
        <T2CORH4_MASK>0x10</T2CORH4_MASK>
        <T2CORH5_MASK>0x20</T2CORH5_MASK>
        <T2CORH6_MASK>0x40</T2CORH6_MASK>
        <T2CORH7_MASK>0x80</T2CORH7_MASK>
      </T2CORH>
      <T2CORL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x70</MEM_ADDR>
        <T2CORL0_MASK>0x01</T2CORL0_MASK>
        <T2CORL1_MASK>0x02</T2CORL1_MASK>
        <T2CORL2_MASK>0x04</T2CORL2_MASK>
        <T2CORL3_MASK>0x08</T2CORL3_MASK>
        <T2CORL4_MASK>0x10</T2CORL4_MASK>
        <T2CORL5_MASK>0x20</T2CORL5_MASK>
        <T2CORL6_MASK>0x40</T2CORL6_MASK>
        <T2CORL7_MASK>0x80</T2CORL7_MASK>
      </T2CORL>
      <T2ICRH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6F</MEM_ADDR>
        <T2ICRH0_MASK>0x01</T2ICRH0_MASK>
        <T2ICRH1_MASK>0x02</T2ICRH1_MASK>
        <T2ICRH2_MASK>0x04</T2ICRH2_MASK>
        <T2ICRH3_MASK>0x08</T2ICRH3_MASK>
        <T2ICRH4_MASK>0x10</T2ICRH4_MASK>
        <T2ICRH5_MASK>0x20</T2ICRH5_MASK>
        <T2ICRH6_MASK>0x40</T2ICRH6_MASK>
        <T2ICRH7_MASK>0x80</T2ICRH7_MASK>
      </T2ICRH>
      <T2ICRL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6E</MEM_ADDR>
        <T2ICRL0_MASK>0x01</T2ICRL0_MASK>
        <T2ICRL1_MASK>0x02</T2ICRL1_MASK>
        <T2ICRL2_MASK>0x04</T2ICRL2_MASK>
        <T2ICRL3_MASK>0x08</T2ICRL3_MASK>
        <T2ICRL4_MASK>0x10</T2ICRL4_MASK>
        <T2ICRL5_MASK>0x20</T2ICRL5_MASK>
        <T2ICRL6_MASK>0x40</T2ICRL6_MASK>
        <T2ICRL7_MASK>0x80</T2ICRL7_MASK>
      </T2ICRL>
      <PCMSK2>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6C</MEM_ADDR>
        <PCINT16_MASK>0x01</PCINT16_MASK>
        <PCINT17_MASK>0x02</PCINT17_MASK>
        <PCINT18_MASK>0x04</PCINT18_MASK>
        <PCINT19_MASK>0x08</PCINT19_MASK>
        <PCINT20_MASK>0x10</PCINT20_MASK>
        <PCINT21_MASK>0x20</PCINT21_MASK>
        <PCINT22_MASK>0x40</PCINT22_MASK>
        <PCINT23_MASK>0x80</PCINT23_MASK>
      </PCMSK2>
      <PCMSK1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6B</MEM_ADDR>
        <PCINT8_MASK>0x01</PCINT8_MASK>
        <PCINT9_MASK>0x02</PCINT9_MASK>
        <PCINT10_MASK>0x04</PCINT10_MASK>
      </PCMSK1>
      <PCMSK0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6A</MEM_ADDR>
        <PCINT0_MASK>0x01</PCINT0_MASK>
        <PCINT1_MASK>0x02</PCINT1_MASK>
        <PCINT2_MASK>0x04</PCINT2_MASK>
        <PCINT3_MASK>0x08</PCINT3_MASK>
        <PCINT4_MASK>0x10</PCINT4_MASK>
        <PCINT5_MASK>0x20</PCINT5_MASK>
        <PCINT6_MASK>0x40</PCINT6_MASK>
        <PCINT7_MASK>0x80</PCINT7_MASK>
      </PCMSK0>
      <EICRA>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x69</MEM_ADDR>
        <ISC00_MASK>0x01</ISC00_MASK>
        <ISC01_MASK>0x02</ISC01_MASK>
        <ISC10_MASK>0x04</ISC10_MASK>
        <ISC11_MASK>0x08</ISC11_MASK>
      </EICRA>
      <MSVCAL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x67</MEM_ADDR>
        <VRCAL0_MASK>0x01</VRCAL0_MASK>
        <VRCAL1_MASK>0x02</VRCAL1_MASK>
        <VRCAL2_MASK>0x04</VRCAL2_MASK>
        <VRCAL3_MASK>0x08</VRCAL3_MASK>
        <VRCAL4_MASK>0x10</VRCAL4_MASK>
        <VRCAL5_MASK>0x20</VRCAL5_MASK>
        <VRCAL6_MASK>0x40</VRCAL6_MASK>
        <VRCAL7_MASK>0x80</VRCAL7_MASK>
      </MSVCAL>
      <FRCCAL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x66</MEM_ADDR>
        <FCAL0_MASK>0x01</FCAL0_MASK>
        <FCAL1_MASK>0x02</FCAL1_MASK>
        <FCAL2_MASK>0x04</FCAL2_MASK>
        <FCAL3_MASK>0x08</FCAL3_MASK>
        <FCAL4_MASK>0x10</FCAL4_MASK>
        <FCAL5_MASK>0x20</FCAL5_MASK>
      </FRCCAL>
      <SRCCAL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x65</MEM_ADDR>
        <SCAL0_MASK>0x01</SCAL0_MASK>
        <SCAL1_MASK>0x02</SCAL1_MASK>
        <SCAL2_MASK>0x04</SCAL2_MASK>
        <SCAL3_MASK>0x08</SCAL3_MASK>
        <SCAL4_MASK>0x10</SCAL4_MASK>
        <SCAL5_MASK>0x20</SCAL5_MASK>
        <SCAL6_MASK>0x40</SCAL6_MASK>
        <SCAL7_MASK>0x80</SCAL7_MASK>
      </SRCCAL>
      <TSCR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x64</MEM_ADDR>
        <TSSD_MASK>0x01</TSSD_MASK>
      </TSCR>
      <SIMSK>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x61</MEM_ADDR>
        <MSIE_MASK>0x01</MSIE_MASK>
      </SIMSK>
      <WDTCR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x60</MEM_ADDR>
        <WDPS0_MASK>0x01</WDPS0_MASK>
        <WDPS1_MASK>0x02</WDPS1_MASK>
        <WDPS2_MASK>0x04</WDPS2_MASK>
        <WDE_MASK>0x08</WDE_MASK>
        <WDCE_MASK>0x10</WDCE_MASK>
      </WDTCR>
      <SREG>
        <IO_ADDR>0x3F</IO_ADDR>
        <MEM_ADDR>0x5F</MEM_ADDR>
        <C_MASK>0x01</C_MASK>
        <Z_MASK>0x02</Z_MASK>
        <N_MASK>0x04</N_MASK>
        <V_MASK>0x08</V_MASK>
        <S_MASK>0x10</S_MASK>
        <H_MASK>0x20</H_MASK>
        <T_MASK>0x40</T_MASK>
        <I_MASK>0x80</I_MASK>
      </SREG>
      <SPH>
        <IO_ADDR>0x3E</IO_ADDR>
        <MEM_ADDR>0x5E</MEM_ADDR>
        <INIT>0x04</INIT>
        <SP8_MASK>0x01</SP8_MASK>
        <SP9_MASK>0x02</SP9_MASK>
        <SP10_MASK>0x04</SP10_MASK>
        <SP11_MASK>0x08</SP11_MASK>
        <SP12_MASK>0x10</SP12_MASK>
        <SP13_MASK>0x20</SP13_MASK>
        <SP14_MASK>0x40</SP14_MASK>
        <SP15_MASK>0x80</SP15_MASK>
      </SPH>
      <SPL>
        <IO_ADDR>0x3D</IO_ADDR>
        <MEM_ADDR>0x5D</MEM_ADDR>
        <INIT>0xFF</INIT>
        <SP0_MASK>0x01</SP0_MASK>
        <SP1_MASK>0x02</SP1_MASK>
        <SP2_MASK>0x04</SP2_MASK>
        <SP3_MASK>0x08</SP3_MASK>
        <SP4_MASK>0x10</SP4_MASK>
        <SP5_MASK>0x20</SP5_MASK>
        <SP6_MASK>0x40</SP6_MASK>
        <SP7_MASK>0x80</SP7_MASK>
      </SPL>
      <CLKPR>
        <IO_ADDR>0x3C</IO_ADDR>
        <MEM_ADDR>0x5C</MEM_ADDR>
        <INIT>0x00</INIT>
        <CLKPS0_MASK>0x01</CLKPS0_MASK>
        <CLKPS1_MASK>0x02</CLKPS1_MASK>
        <CLKPS2_MASK>0x04</CLKPS2_MASK>
        <CLTPS0_MASK>0x08</CLTPS0_MASK>
        <CLTPS1_MASK>0x10</CLTPS1_MASK>
        <CLTPS2_MASK>0x20</CLTPS2_MASK>
        <CLPCE_MASK>0x80</CLPCE_MASK>
      </CLKPR>
      <CMIMR>
        <IO_ADDR>0x3B</IO_ADDR>
        <MEM_ADDR>0x5B</MEM_ADDR>
        <INIT>0x00</INIT>
        <ECIE_MASK>0x01</ECIE_MASK>
      </CMIMR>
      <T0CR>
        <IO_ADDR>0x39</IO_ADDR>
        <MEM_ADDR>0x59</MEM_ADDR>
        <T0PAS0_MASK>0x01</T0PAS0_MASK>
        <T0PAS1_MASK>0x02</T0PAS1_MASK>
        <T0PAS2_MASK>0x04</T0PAS2_MASK>
        <T0IE_MASK>0x08</T0IE_MASK>
        <T0PR_MASK>0x10</T0PR_MASK>
        <T0PBS0_MASK>0x20</T0PBS0_MASK>
        <T0PBS1_MASK>0x40</T0PBS1_MASK>
        <T0PBS2_MASK>0x80</T0PBS2_MASK>
      </T0CR>
      <T1CR>
        <IO_ADDR>0x38</IO_ADDR>
        <MEM_ADDR>0x58</MEM_ADDR>
        <T1PS0_MASK>0x01</T1PS0_MASK>
        <T1PS1_MASK>0x02</T1PS1_MASK>
        <T1PS2_MASK>0x04</T1PS2_MASK>
        <T1CS0_MASK>0x08</T1CS0_MASK>
        <T1CS1_MASK>0x10</T1CS1_MASK>
        <T1CS2_MASK>0x20</T1CS2_MASK>
        <T1IE_MASK>0x80</T1IE_MASK>
      </T1CR>
      <SPMCSR>
        <IO_ADDR>0x37</IO_ADDR>
        <MEM_ADDR>0x57</MEM_ADDR>
        <SELFPRGEN_MASK>0x01</SELFPRGEN_MASK>
        <PGERS_MASK>0x02</PGERS_MASK>
        <PGWRT_MASK>0x04</PGWRT_MASK>
        <BLBSET_MASK>0x08</BLBSET_MASK>
        <RWWSRE_MASK>0x10</RWWSRE_MASK>
        <RWWSB_MASK>0x40</RWWSB_MASK>
        <SPMIE_MASK>0x80</SPMIE_MASK>
      </SPMCSR>
      <LFRB>
        <IO_ADDR>0x36</IO_ADDR>
        <MEM_ADDR>0x56</MEM_ADDR>
        <LFRB0_MASK>0x01</LFRB0_MASK>
        <LFRB1_MASK>0x02</LFRB1_MASK>
        <LFRB2_MASK>0x04</LFRB2_MASK>
        <LFRB3_MASK>0x08</LFRB3_MASK>
        <LFRB4_MASK>0x10</LFRB4_MASK>
        <LFRB5_MASK>0x20</LFRB5_MASK>
        <LFRB6_MASK>0x40</LFRB6_MASK>
        <LFRB7_MASK>0x80</LFRB7_MASK>
      </LFRB>
      <MCUCR>
        <IO_ADDR>0x35</IO_ADDR>
        <MEM_ADDR>0x55</MEM_ADDR>
        <IVCE_MASK>0x01</IVCE_MASK>
        <IVSEL_MASK>0x02</IVSEL_MASK>
        <PUD_MASK>0x10</PUD_MASK>
      </MCUCR>
      <MCUSR>
        <IO_ADDR>0x34</IO_ADDR>
        <MEM_ADDR>0x54</MEM_ADDR>
        <PORF_MASK>0x01</PORF_MASK>
        <EXTRF_MASK>0x02</EXTRF_MASK>
        <BORF_MASK>0x04</BORF_MASK>
        <WDRF_MASK>0x08</WDRF_MASK>
        <TSRF_MASK>0x20</TSRF_MASK>
      </MCUSR>
      <SMCR>
        <IO_ADDR>0x33</IO_ADDR>
        <MEM_ADDR>0x53</MEM_ADDR>
        <SE_MASK>0x01</SE_MASK>
        <SM0_MASK>0x02</SM0_MASK>
        <SM1_MASK>0x04</SM1_MASK>
        <SM2_MASK>0x08</SM2_MASK>
      </SMCR>
      <LFCDR>
        <IO_ADDR>0x32</IO_ADDR>
        <MEM_ADDR>0x52</MEM_ADDR>
        <LFDO_MASK>0x01</LFDO_MASK>
        <LFRST_MASK>0x40</LFRST_MASK>
        <LFSCE_MASK>0x80</LFSCE_MASK>
      </LFCDR>
      <LFRR>
        <IO_ADDR>0x30</IO_ADDR>
        <MEM_ADDR>0x50</MEM_ADDR>
        <LFRR0_MASK>0x01</LFRR0_MASK>
        <LFRR1_MASK>0x02</LFRR1_MASK>
        <LFRR2_MASK>0x04</LFRR2_MASK>
        <LFRR3_MASK>0x08</LFRR3_MASK>
        <LFRR4_MASK>0x10</LFRR4_MASK>
        <LFRR5_MASK>0x20</LFRR5_MASK>
        <LFRR6_MASK>0x40</LFRR6_MASK>
      </LFRR>
      <T2MDR>
        <IO_ADDR>0x2F</IO_ADDR>
        <MEM_ADDR>0x4F</MEM_ADDR>
        <T2MDR0_MASK>0x01</T2MDR0_MASK>
        <T2MDR1_MASK>0x02</T2MDR1_MASK>
        <T2MDR2_MASK>0x04</T2MDR2_MASK>
        <T2MDR3_MASK>0x08</T2MDR3_MASK>
        <T2MDR4_MASK>0x10</T2MDR4_MASK>
        <T2MDR5_MASK>0x20</T2MDR5_MASK>
        <T2MDR6_MASK>0x40</T2MDR6_MASK>
        <T2MDR7_MASK>0x80</T2MDR7_MASK>
      </T2MDR>
      <SPDR>
        <IO_ADDR>0x2E</IO_ADDR>
        <MEM_ADDR>0x4E</MEM_ADDR>
        <SPDR0_MASK>0x01</SPDR0_MASK>
        <SPDR1_MASK>0x02</SPDR1_MASK>
        <SPDR2_MASK>0x04</SPDR2_MASK>
        <SPDR3_MASK>0x08</SPDR3_MASK>
        <SPDR4_MASK>0x10</SPDR4_MASK>
        <SPDR5_MASK>0x20</SPDR5_MASK>
        <SPDR6_MASK>0x40</SPDR6_MASK>
        <SPDR7_MASK>0x80</SPDR7_MASK>
      </SPDR>
      <SPSR>
        <IO_ADDR>0x2D</IO_ADDR>
        <MEM_ADDR>0x4D</MEM_ADDR>
        <SPI2X_MASK>0x01</SPI2X_MASK>
        <WCOL_MASK>0x40</WCOL_MASK>
        <SPIF_MASK>0x80</SPIF_MASK>
      </SPSR>
      <SPCR>
        <IO_ADDR>0x2C</IO_ADDR>
        <MEM_ADDR>0x4C</MEM_ADDR>
        <SPR0_MASK>0x01</SPR0_MASK>
        <SPR1_MASK>0x02</SPR1_MASK>
        <CPHA_MASK>0x04</CPHA_MASK>
        <CPOL_MASK>0x08</CPOL_MASK>
        <MSTR_MASK>0x10</MSTR_MASK>
        <DORD_MASK>0x20</DORD_MASK>
        <SPE_MASK>0x40</SPE_MASK>
        <SPIE_MASK>0x80</SPIE_MASK>
      </SPCR>
      <GPIOR2>
        <IO_ADDR>0x2B</IO_ADDR>
        <MEM_ADDR>0x4B</MEM_ADDR>
        <GPIOR20_MASK>0x01</GPIOR20_MASK>
        <GPIOR21_MASK>0x02</GPIOR21_MASK>
        <GPIOR22_MASK>0x04</GPIOR22_MASK>
        <GPIOR23_MASK>0x08</GPIOR23_MASK>
        <GPIOR24_MASK>0x10</GPIOR24_MASK>
        <GPIOR25_MASK>0x20</GPIOR25_MASK>
        <GPIOR26_MASK>0x40</GPIOR26_MASK>
        <GPIOR27_MASK>0x80</GPIOR27_MASK>
      </GPIOR2>
      <GPIOR1>
        <IO_ADDR>0x2A</IO_ADDR>
        <MEM_ADDR>0x4A</MEM_ADDR>
        <GPIOR10_MASK>0x01</GPIOR10_MASK>
        <GPIOR11_MASK>0x02</GPIOR11_MASK>
        <GPIOR12_MASK>0x04</GPIOR12_MASK>
        <GPIOR13_MASK>0x08</GPIOR13_MASK>
        <GPIOR14_MASK>0x10</GPIOR14_MASK>
        <GPIOR15_MASK>0x20</GPIOR15_MASK>
        <GPIOR16_MASK>0x40</GPIOR16_MASK>
        <GPIOR17_MASK>0x80</GPIOR17_MASK>
      </GPIOR1>
      <SCCR>
        <IO_ADDR>0x29</IO_ADDR>
        <MEM_ADDR>0x49</MEM_ADDR>
        <SRCC0_MASK>0x01</SRCC0_MASK>
        <SRCC1_MASK>0x02</SRCC1_MASK>
        <SCCS0_MASK>0x04</SCCS0_MASK>
        <SCCS1_MASK>0x08</SCCS1_MASK>
        <SCCS2_MASK>0x10</SCCS2_MASK>
      </SCCR>
      <SCR>
        <IO_ADDR>0x28</IO_ADDR>
        <MEM_ADDR>0x48</MEM_ADDR>
        <SMS_MASK>0x01</SMS_MASK>
        <SEN0_MASK>0x02</SEN0_MASK>
        <SEN1_MASK>0x04</SEN1_MASK>
        <SMEN_MASK>0x08</SMEN_MASK>
      </SCR>
      <SVCR>
        <IO_ADDR>0x27</IO_ADDR>
        <MEM_ADDR>0x47</MEM_ADDR>
        <SVCS0_MASK>0x01</SVCS0_MASK>
        <SVCS1_MASK>0x02</SVCS1_MASK>
        <SVCS2_MASK>0x04</SVCS2_MASK>
        <SVCS3_MASK>0x08</SVCS3_MASK>
        <SVCS4_MASK>0x10</SVCS4_MASK>
      </SVCR>
      <EIMSK>
        <IO_ADDR>0x24</IO_ADDR>
        <MEM_ADDR>0x44</MEM_ADDR>
        <INT0_MASK>0x01</INT0_MASK>
        <INT1_MASK>0x02</INT1_MASK>
      </EIMSK>
      <PCICR>
        <IO_ADDR>0x23</IO_ADDR>
        <MEM_ADDR>0x43</MEM_ADDR>
        <PCIE0_MASK>0x01</PCIE0_MASK>
        <PCIE1_MASK>0x02</PCIE1_MASK>
        <PCIE2_MASK>0x04</PCIE2_MASK>
      </PCICR>
      <EEARH>
        <IO_ADDR>0x22</IO_ADDR>
        <MEM_ADDR>0x42</MEM_ADDR>
        <EEAR8_MASK>0x01</EEAR8_MASK>
      </EEARH>
      <EEARL>
        <IO_ADDR>0x21</IO_ADDR>
        <MEM_ADDR>0x41</MEM_ADDR>
        <EEAR0_MASK>0x01</EEAR0_MASK>
        <EEAR1_MASK>0x02</EEAR1_MASK>
        <EEAR2_MASK>0x04</EEAR2_MASK>
        <EEAR3_MASK>0x08</EEAR3_MASK>
        <EEAR4_MASK>0x10</EEAR4_MASK>
        <EEAR5_MASK>0x20</EEAR5_MASK>
        <EEAR6_MASK>0x40</EEAR6_MASK>
        <EEAR7_MASK>0x80</EEAR7_MASK>
      </EEARL>
      <EEDR>
        <IO_ADDR>0x20</IO_ADDR>
        <MEM_ADDR>0x40</MEM_ADDR>
        <EEDR0_MASK>0x01</EEDR0_MASK>
        <EEDR1_MASK>0x02</EEDR1_MASK>
        <EEDR2_MASK>0x04</EEDR2_MASK>
        <EEDR3_MASK>0x08</EEDR3_MASK>
        <EEDR4_MASK>0x10</EEDR4_MASK>
        <EEDR5_MASK>0x20</EEDR5_MASK>
        <EEDR6_MASK>0x40</EEDR6_MASK>
        <EEDR7_MASK>0x80</EEDR7_MASK>
      </EEDR>
      <EECR>
        <IO_ADDR>0x1F</IO_ADDR>
        <MEM_ADDR>0x3F</MEM_ADDR>
        <EERE_MASK>0x01</EERE_MASK>
        <EEWE_MASK>0x02</EEWE_MASK>
        <EEMWE_MASK>0x04</EEMWE_MASK>
        <EERIE_MASK>0x08</EERIE_MASK>
        <EEPM0_MASK>0x10</EEPM0_MASK>
        <EEPM1_MASK>0x20</EEPM1_MASK>
      </EECR>
      <GPIOR0>
        <IO_ADDR>0x1E</IO_ADDR>
        <MEM_ADDR>0x3E</MEM_ADDR>
        <GPIOR00_MASK>0x01</GPIOR00_MASK>
        <GPIOR01_MASK>0x02</GPIOR01_MASK>
        <GPIOR02_MASK>0x04</GPIOR02_MASK>
        <GPIOR03_MASK>0x08</GPIOR03_MASK>
        <GPIOR04_MASK>0x10</GPIOR04_MASK>
        <GPIOR05_MASK>0x20</GPIOR05_MASK>
        <GPIOR06_MASK>0x40</GPIOR06_MASK>
        <GPIOR07_MASK>0x80</GPIOR07_MASK>
      </GPIOR0>
      <EIFR>
        <IO_ADDR>0x1D</IO_ADDR>
        <MEM_ADDR>0x3D</MEM_ADDR>
        <INTF0_MASK>0x01</INTF0_MASK>
        <INTF1_MASK>0x02</INTF1_MASK>
      </EIFR>
      <T3IFR>
        <IO_ADDR>0x1C</IO_ADDR>
        <MEM_ADDR>0x3C</MEM_ADDR>
        <T3OFF_MASK>0x01</T3OFF_MASK>
        <T3COAF_MASK>0x02</T3COAF_MASK>
        <T3COBF_MASK>0x04</T3COBF_MASK>
        <T3ICF_MASK>0x08</T3ICF_MASK>
      </T3IFR>
      <T2IFR>
        <IO_ADDR>0x1B</IO_ADDR>
        <MEM_ADDR>0x3B</MEM_ADDR>
        <T2OFF_MASK>0x01</T2OFF_MASK>
        <T2COF_MASK>0x02</T2COF_MASK>
        <T2ICF_MASK>0x04</T2ICF_MASK>
        <T2RXF_MASK>0x08</T2RXF_MASK>
        <T2TXF_MASK>0x10</T2TXF_MASK>
        <T2TCF_MASK>0x20</T2TCF_MASK>
      </T2IFR>
      <T10IFR>
        <IO_ADDR>0x1A</IO_ADDR>
        <MEM_ADDR>0x3A</MEM_ADDR>
        <T0F_MASK>0x01</T0F_MASK>
        <T1F_MASK>0x02</T1F_MASK>
      </T10IFR>
      <SSFR>
        <IO_ADDR>0x19</IO_ADDR>
        <MEM_ADDR>0x39</MEM_ADDR>
        <MSENF_MASK>0x01</MSENF_MASK>
        <MSENO_MASK>0x02</MSENO_MASK>
      </SSFR>
      <LFFR>
        <IO_ADDR>0x18</IO_ADDR>
        <MEM_ADDR>0x38</MEM_ADDR>
        <LFWPF_MASK>0x01</LFWPF_MASK>
        <LFBF_MASK>0x02</LFBF_MASK>
        <LFEDF_MASK>0x04</LFEDF_MASK>
        <LFRF_MASK>0x08</LFRF_MASK>
      </LFFR>
      <PCIFR>
        <IO_ADDR>0x17</IO_ADDR>
        <MEM_ADDR>0x37</MEM_ADDR>
        <PCIF0_MASK>0x01</PCIF0_MASK>
        <PCIF1_MASK>0x02</PCIF1_MASK>
        <PCIF2_MASK>0x04</PCIF2_MASK>
      </PCIFR>
      <VMCSR>
        <IO_ADDR>0x16</IO_ADDR>
        <MEM_ADDR>0x36</MEM_ADDR>
        <VMEN_MASK>0x01</VMEN_MASK>
        <VMLS0_MASK>0x02</VMLS0_MASK>
        <VMLS1_MASK>0x04</VMLS1_MASK>
        <VMLS2_MASK>0x08</VMLS2_MASK>
        <VMIM_MASK>0x10</VMIM_MASK>
        <VMF_MASK>0x20</VMF_MASK>
        <BODPD_MASK>0x40</BODPD_MASK>
        <BODLS_MASK>0x80</BODLS_MASK>
      </VMCSR>
      <T3CRA>
        <IO_ADDR>0x14</IO_ADDR>
        <MEM_ADDR>0x34</MEM_ADDR>
        <T3AC_MASK>0x01</T3AC_MASK>
        <T3SCE_MASK>0x02</T3SCE_MASK>
        <T3CR_MASK>0x04</T3CR_MASK>
        <T3TS_MASK>0x40</T3TS_MASK>
        <T3E_MASK>0x80</T3E_MASK>
      </T3CRA>
      <T2CRB>
        <IO_ADDR>0x12</IO_ADDR>
        <MEM_ADDR>0x32</MEM_ADDR>
        <T2SCE_MASK>0x01</T2SCE_MASK>
      </T2CRB>
      <T2CRA>
        <IO_ADDR>0x11</IO_ADDR>
        <MEM_ADDR>0x31</MEM_ADDR>
        <T2OTM_MASK>0x01</T2OTM_MASK>
        <T2CTM_MASK>0x02</T2CTM_MASK>
        <T2CR_MASK>0x04</T2CR_MASK>
        <T2CRM_MASK>0x08</T2CRM_MASK>
        <T2ICS_MASK>0x20</T2ICS_MASK>
        <T2TS_MASK>0x40</T2TS_MASK>
        <T2E_MASK>0x80</T2E_MASK>
      </T2CRA>
      <CMSR>
        <IO_ADDR>0x10</IO_ADDR>
        <MEM_ADDR>0x30</MEM_ADDR>
        <ECF_MASK>0x01</ECF_MASK>
      </CMSR>
      <CMCR>
        <IO_ADDR>0x0F</IO_ADDR>
        <MEM_ADDR>0x2F</MEM_ADDR>
        <CMM0_MASK>0x01</CMM0_MASK>
        <CMM1_MASK>0x02</CMM1_MASK>
        <SRCD_MASK>0x04</SRCD_MASK>
        <CMONEN_MASK>0x08</CMONEN_MASK>
        <CCS_MASK>0x10</CCS_MASK>
        <ECINS_MASK>0x20</ECINS_MASK>
        <CMCCE_MASK>0x80</CMCCE_MASK>
      </CMCR>
      <PORTD>
        <IO_ADDR>0x0B</IO_ADDR>
        <MEM_ADDR>0x2B</MEM_ADDR>
        <PORTD0_MASK>0x01</PORTD0_MASK>
        <PORTD1_MASK>0x02</PORTD1_MASK>
        <PORTD2_MASK>0x04</PORTD2_MASK>
        <PORTD3_MASK>0x08</PORTD3_MASK>
        <PORTD4_MASK>0x10</PORTD4_MASK>
        <PORTD5_MASK>0x20</PORTD5_MASK>
        <PORTD6_MASK>0x40</PORTD6_MASK>
        <PORTD7_MASK>0x80</PORTD7_MASK>
      </PORTD>
      <DDRD>
        <IO_ADDR>0x0A</IO_ADDR>
        <MEM_ADDR>0x2A</MEM_ADDR>
        <DDD0_MASK>0x01</DDD0_MASK>
        <DDD1_MASK>0x02</DDD1_MASK>
        <DDD2_MASK>0x04</DDD2_MASK>
        <DDD3_MASK>0x08</DDD3_MASK>
        <DDD4_MASK>0x10</DDD4_MASK>
        <DDD5_MASK>0x20</DDD5_MASK>
        <DDD6_MASK>0x40</DDD6_MASK>
        <DDD7_MASK>0x80</DDD7_MASK>
      </DDRD>
      <PIND>
        <IO_ADDR>0x09</IO_ADDR>
        <MEM_ADDR>0x29</MEM_ADDR>
        <PIND0_MASK>0x01</PIND0_MASK>
        <PIND1_MASK>0x02</PIND1_MASK>
        <PIND2_MASK>0x04</PIND2_MASK>
        <PIND3_MASK>0x08</PIND3_MASK>
        <PIND4_MASK>0x10</PIND4_MASK>
        <PIND5_MASK>0x20</PIND5_MASK>
        <PIND6_MASK>0x40</PIND6_MASK>
        <PIND7_MASK>0x80</PIND7_MASK>
      </PIND>
      <PORTC>
        <IO_ADDR>0x08</IO_ADDR>
        <MEM_ADDR>0x28</MEM_ADDR>
        <PORTC0_MASK>0x01</PORTC0_MASK>
        <PORTC1_MASK>0x02</PORTC1_MASK>
        <PORTC2_MASK>0x04</PORTC2_MASK>
      </PORTC>
      <DDRC>
        <IO_ADDR>0x07</IO_ADDR>
        <MEM_ADDR>0x27</MEM_ADDR>
        <DDC0_MASK>0x01</DDC0_MASK>
        <DDC1_MASK>0x02</DDC1_MASK>
        <DDC2_MASK>0x04</DDC2_MASK>
      </DDRC>
      <PINC>
        <IO_ADDR>0x06</IO_ADDR>
        <MEM_ADDR>0x26</MEM_ADDR>
        <PINC0_MASK>0x01</PINC0_MASK>
        <PINC1_MASK>0x02</PINC1_MASK>
        <PINC2_MASK>0x04</PINC2_MASK>
      </PINC>
      <PORTB>
        <IO_ADDR>0x05</IO_ADDR>
        <MEM_ADDR>0x25</MEM_ADDR>
        <PORTB0_MASK>0x01</PORTB0_MASK>
        <PORTB1_MASK>0x02</PORTB1_MASK>
        <PORTB2_MASK>0x04</PORTB2_MASK>
        <PORTB3_MASK>0x08</PORTB3_MASK>
        <PORTB4_MASK>0x10</PORTB4_MASK>
        <PORTB5_MASK>0x20</PORTB5_MASK>
        <PORTB6_MASK>0x40</PORTB6_MASK>
        <PORTB7_MASK>0x80</PORTB7_MASK>
      </PORTB>
      <DDRB>
        <IO_ADDR>0x04</IO_ADDR>
        <MEM_ADDR>0x24</MEM_ADDR>
        <DDB0_MASK>0x01</DDB0_MASK>
        <DDB1_MASK>0x02</DDB1_MASK>
        <DDB2_MASK>0x04</DDB2_MASK>
        <DDB3_MASK>0x08</DDB3_MASK>
        <DDB4_MASK>0x10</DDB4_MASK>
        <DDB5_MASK>0x20</DDB5_MASK>
        <DDB6_MASK>0x40</DDB6_MASK>
        <DDB7_MASK>0x80</DDB7_MASK>
      </DDRB>
      <PINB>
        <IO_ADDR>0x03</IO_ADDR>
        <MEM_ADDR>0x23</MEM_ADDR>
        <PINB0_MASK>0x01</PINB0_MASK>
        <PINB1_MASK>0x02</PINB1_MASK>
        <PINB2_MASK>0x04</PINB2_MASK>
        <PINB3_MASK>0x08</PINB3_MASK>
        <PINB4_MASK>0x10</PINB4_MASK>
        <PINB5_MASK>0x20</PINB5_MASK>
        <PINB6_MASK>0x40</PINB6_MASK>
        <PINB7_MASK>0x80</PINB7_MASK>
      </PINB>
    </IO_MEMORY>
    <BOOT_CONFIG>
      <NRWW_START_ADDR>$C00</NRWW_START_ADDR>
      <NRWW_STOP_ADDR>$FFF</NRWW_STOP_ADDR>
      <RWW_START_ADDR>$0</RWW_START_ADDR>
      <RWW_STOP_ADDR>$BFF</RWW_STOP_ADDR>
      <PAGESIZE>32</PAGESIZE>
      <BOOTSZMODE1>
        <BOOTSIZE>128</BOOTSIZE>
        <PAGES>4</PAGES>
        <APPSTART>$0</APPSTART>
        <BOOTSTART>$F80</BOOTSTART>
        <BOOTRESET>$F80</BOOTRESET>
      </BOOTSZMODE1>
      <BOOTSZMODE2>
        <BOOTSIZE>256</BOOTSIZE>
        <PAGES>8</PAGES>
        <APPSTART>$0</APPSTART>
        <BOOTSTART>$F00</BOOTSTART>
        <BOOTRESET>$F00</BOOTRESET>
      </BOOTSZMODE2>
      <BOOTSZMODE3>
        <BOOTSIZE>512</BOOTSIZE>
        <PAGES>16</PAGES>
        <APPSTART>$0</APPSTART>
        <BOOTSTART>$E00</BOOTSTART>
        <BOOTRESET>$E00</BOOTRESET>
      </BOOTSZMODE3>
      <BOOTSZMODE4>
        <BOOTSIZE>1024</BOOTSIZE>
        <PAGES>32</PAGES>
        <APPSTART>$0</APPSTART>
        <BOOTSTART>$C00</BOOTSTART>
        <BOOTRESET>$C00</BOOTRESET>
      </BOOTSZMODE4>
    </BOOT_CONFIG>
  </MEMORY>
  <PACKAGE>
    <PACKAGES>[QFN]</PACKAGES>
    <QFN>
      <NMB_PIN>32</NMB_PIN>
      <PIN1>
        <NAME>[PB4:MISO:PCINT4]</NAME>
        <TEXT>MISO:Master data Input,Slave data Output pin for SPI channel.When the SPI is enabled as a master,this pin is configured as an input regardless of the setting of DDB4.When the SPI is enabled as a slave,the data direction of this pin is controlled by DDB4.When the pin is forced by the SPI to be an input,the pull-up can still be controlled by the PORTB4 bit.</TEXT>
      </PIN1>
      <PIN2>
        <NAME>[PB5:SCK:PCINT5]</NAME>
        <TEXT>SCK:Master clock output,slave clock input pin for SPI channel.When the SPI is enabled as a slave,this pin is configured as an input regardless of the setting of DDB5.When the SPI is enabled as a master,the data direction of this pin is controlled by DDB5.When the pin is forced by the SPI to be an input,the pull-up can still be controlled by the PORTB5 bit.</TEXT>
      </PIN2>
      <PIN3>
        <NAME>[ANT2]</NAME>
        <TEXT>RF-Antenna </TEXT>
      </PIN3>
      <PIN4>
        <NAME>[ANT1]</NAME>
        <TEXT>RF-Antenna</TEXT>
      </PIN4>
      <PIN5>
        <NAME>[PB1:T3O:PCINT1]</NAME>
        <TEXT>Timer 3 Output Signal</TEXT>
      </PIN5>
      <PIN6>
        <NAME>[PB6:PCINT6]</NAME>
        <TEXT/>
      </PIN6>
      <PIN7>
        <NAME>[PB7:NSS:PCINT7]</NAME>
        <TEXT>SS:Slave Select input.When the SPI is enabled as a slave,this pin is configured as an input regardless of the setting of DDB7.As a slave,the SPI is activated when this pin is driven low.When the SPI is enabled as a master,the data direction of this pin is controlled by DDB7.When the pin is forced by the SPI to be an input,the pull-up can still be controlled by the PORTB7 bit. </TEXT>
      </PIN7>
      <PIN8>
        <NAME>[XTO2]</NAME>
        <TEXT>Switch for FSK modulation</TEXT>
      </PIN8>
      <PIN9>
        <NAME>[PB2:T2I:PCINT2]</NAME>
        <TEXT>Timer 2 external input clock</TEXT>
      </PIN9>
      <PIN10>
        <NAME>[XTO1]</NAME>
        <TEXT>Connection for the TX crystal</TEXT>
      </PIN10>
      <PIN11>
        <NAME>[VS_RF]</NAME>
        <TEXT>Power suppliy voltage for RF transmitter</TEXT>
      </PIN11>
      <PIN12>
        <NAME>[GND_RF]</NAME>
        <TEXT>Ground for RF transmitter</TEXT>
      </PIN12>
      <PIN13>
        <NAME>[NRESET:debugWIRE]</NAME>
        <TEXT>Reset input / debugWIRE interface</TEXT>
      </PIN13>
      <PIN14>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN14>
      <PIN15>
        <NAME>[S0]</NAME>
        <TEXT>Sensor input 0 - Pressure sensor (Cap.)</TEXT>
      </PIN15>
      <PIN16>
        <NAME>[S1]</NAME>
        <TEXT>Sensor input 1 - X-Motion sensor (Cap.)</TEXT>
      </PIN16>
      <PIN17>
        <NAME>[S2]</NAME>
        <TEXT>Sensor input 2 - Z-Motion sensor (Cap.)</TEXT>
      </PIN17>
      <PIN18>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN18>
      <PIN19>
        <NAME>[LF1]</NAME>
        <TEXT>LF-Receiver input 1</TEXT>
      </PIN19>
      <PIN20>
        <NAME>[LF2]</NAME>
        <TEXT>LF-Receiver input 2</TEXT>
      </PIN20>
      <PIN21>
        <NAME>[VCC]</NAME>
        <TEXT/>
      </PIN21>
      <PIN22>
        <NAME>[PC2:PCINT10]</NAME>
        <TEXT/>
      </PIN22>
      <PIN23>
        <NAME>[PC1:CLKO:PCINT9]</NAME>
        <TEXT>System Clock Output</TEXT>
      </PIN23>
      <PIN24>
        <NAME>[PC0:ECIN0:PCINT8]</NAME>
        <TEXT>External Clock Input 0</TEXT>
      </PIN24>
      <PIN25>
        <NAME>[PD0:T2ICP:PCINT16]</NAME>
        <TEXT>Timer 2 external input capture</TEXT>
      </PIN25>
      <PIN26>
        <NAME>[PD1:T3I:PCINT17]</NAME>
        <TEXT>Timer 3 external input clock</TEXT>
      </PIN26>
      <PIN27>
        <NAME>[PB0:T3ICP:PCINT0]</NAME>
        <TEXT>Timer3 external input capture </TEXT>
      </PIN27>
      <PIN28>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN28>
      <PIN29>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN29>
      <PIN30>
        <NAME>[PD7:SDIN:PCINT23]</NAME>
        <TEXT>SSI - Serial Data Input</TEXT>
      </PIN30>
      <PIN31>
        <NAME>[PD2:INT0:PCINT18]</NAME>
        <TEXT>External interrupt input</TEXT>
      </PIN31>
      <PIN32>
        <NAME>[PB3:MOSI:PCINT3]</NAME>
        <TEXT>MOSI:SPI Master data output,slave data input for SPI channel.When the SPI is enabled as a slave,this pin is configured as an input regardless of the setting of DDB3.When the SPI is enabled as a master,the data direction of this pin is controlled by DDB3.When the pin is forced by the SPI to be an input,the pull-up can still be controlled by the PORTB bit.</TEXT>
      </PIN32>
    </QFN>
  </PACKAGE>
  <PROGRAMMING>
    <ISPInterface>
      <FuseReadMask>0xff,0xdf,0xff</FuseReadMask>
      <FuseProgMask>0xff,0xdf,0xff</FuseProgMask>
      <FuseWarning>1,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
      <FuseWarning>1,0x80,0x00,WARNING! Upper EEPROM area (callibration area) will be locked!</FuseWarning>
      <FuseWarning>1,0x40,0x00,WARNING! Enabling DebugWIRE will make the ISP interface inaccessible!</FuseWarning>
      <FuseWarning>0,0x80,0x00,WARNING! Using this clock option together with the CKDIV8 fuse will disable further ISP programming!</FuseWarning>
    </ISPInterface>
    <HVInterface>
      <FuseWarning>1,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
      <FuseWarning>1,0x80,0x00,WARNING! Upper EEPROM area (callibration area) will be locked!</FuseWarning>
      <FuseWarning>1,0x40,0x00,WARNING! Enabling DEBUGWIRE will make the ISP interface inaccessible!</FuseWarning>
      <FuseWarning>0,0x80,0x00,WARNING! Using this clock option together with the CKDIV8 fuse will disable further ISP programming!</FuseWarning>
    </HVInterface>
    <OscCal>
      <OCEntry>0x00,4.0 MHz</OCEntry>
    </OscCal>
    <FlashPageSize>64</FlashPageSize>
    <EepromPageSize>4</EepromPageSize>
  </PROGRAMMING>
  <LOCKBIT>
    <ICON/>
    <ID/>
    <TEXT>[LB1 = 1 :  LB2 = 1] No memory lock features enabled. [LB1 = 0 :  LB2 = 1] Further programming of Flash and EEPROM is enabled. [LB1 = 0 :  LB2 = 0] Same as previous, but verify is also disabled</TEXT>
    <NMB_LOCK_BITS>6</NMB_LOCK_BITS>
    <NMB_TEXT>11</NMB_TEXT>
    <TEXT1>
      <MASK>0x03</MASK>
      <VALUE>0x03</VALUE>
      <TEXT>Mode 1: No memory lock features enabled</TEXT>
    </TEXT1>
    <TEXT2>
      <MASK>0x03</MASK>
      <VALUE>0x02</VALUE>
      <TEXT>Mode 2: Further programming disabled</TEXT>
    </TEXT2>
    <TEXT3>
      <MASK>0x03</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Mode 3: Further programming and verification disabled</TEXT>
    </TEXT3>
    <TEXT4>
      <MASK>0x0C</MASK>
      <VALUE>0x0C</VALUE>
      <TEXT>Application Protection Mode 1: No lock on SPM and LPM in Application Section</TEXT>
    </TEXT4>
    <TEXT5>
      <MASK>0x0C</MASK>
      <VALUE>0x08</VALUE>
      <TEXT>Application Protection Mode 2: SPM prohibited in Application Section</TEXT>
    </TEXT5>
    <TEXT6>
      <MASK>0x0C</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Application Protection Mode 3: LPM and SPM prohibited in Application Section</TEXT>
    </TEXT6>
    <TEXT7>
      <MASK>0x0C</MASK>
      <VALUE>0x04</VALUE>
      <TEXT>Application Protection Mode 4: LPM prohibited in Application Section</TEXT>
    </TEXT7>
    <TEXT8>
      <MASK>0x30</MASK>
      <VALUE>0x30</VALUE>
      <TEXT>Boot Loader Protection Mode 1: No lock on SPM and LPM in Boot Loader Section</TEXT>
    </TEXT8>
    <TEXT9>
      <MASK>0x30</MASK>
      <VALUE>0x20</VALUE>
      <TEXT>Boot Loader Protection Mode 2: SPM prohibited in Boot Loader Section</TEXT>
    </TEXT9>
    <TEXT10>
      <MASK>0x30</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Boot Loader Protection Mode 3: LPM and SPM prohibited in Boot Loader Section</TEXT>
    </TEXT10>
    <TEXT11>
      <MASK>0x30</MASK>
      <VALUE>0x10</VALUE>
      <TEXT>Boot Loader Protection Mode 4: LPM prohibited in Boot Loader Section</TEXT>
    </TEXT11>
    <LOCKBIT0>
      <NAME>LB1</NAME>
      <TEXT>Lock bit</TEXT>
    </LOCKBIT0>
    <LOCKBIT1>
      <NAME>LB2</NAME>
      <TEXT>Lock bit</TEXT>
    </LOCKBIT1>
    <LOCKBIT2>
      <NAME>BLB01</NAME>
      <TEXT>Boot Lock bit</TEXT>
    </LOCKBIT2>
    <LOCKBIT3>
      <NAME>BLB02</NAME>
      <TEXT>Boot Lock bit</TEXT>
    </LOCKBIT3>
    <LOCKBIT4>
      <NAME>BLB11</NAME>
      <TEXT>Boot lock bit</TEXT>
    </LOCKBIT4>
    <LOCKBIT5>
      <NAME>BLB12</NAME>
      <TEXT>Boot lock bit</TEXT>
    </LOCKBIT5>
  </LOCKBIT>
  <IO_MODULE>
    <MODULE_LIST>[SENSOR_INTERFACE:SPI:CPU:LFRX:EXTERNAL_INTERRUPT:PORTB:PORTD:TIMER_COUNTER_1:TIMER_COUNTER_2:TIMER_COUNTER_3:WATCHDOG:TIMER_COUNTER_0:EEPROM:PORTC]</MODULE_LIST>
    <SENSOR_INTERFACE>
      <LIST>[SCR:MSVCAL:SCCR:SVCR:SIMSK:SSFR:TSCR]</LIST>
      <LINK/>
      <ICON>io_analo.bmp</ICON>
      <ID/>
      <TEXT>Sensor Interface Feature list: Motion Sensor Interface with wake up function; Capacitive Sensor Interface; Voltage Interface and Temperature Measurement with thermal shutdown mode</TEXT>
      <MSVCAL>
        <NAME>MSVCAL</NAME>
        <DESCRIPTION>Motion Sensor Voltage Calibration Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x67</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>VRCAL7</NAME>
          <DESCRIPTION>Voltage Reference Calibration Bit 7</DESCRIPTION>
          <TEXT>The Voltage Reference Calibration Register is used to trim the internal voltage reference for the motion comparator threshold level.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>VRCAL6</NAME>
          <DESCRIPTION>Voltage Reference Calibration Bit 6</DESCRIPTION>
          <TEXT>The Voltage Reference Calibration Register is used to trim the internal voltage reference for the motion comparator threshold level.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>VRCAL5</NAME>
          <DESCRIPTION>Voltage Reference Calibration Bit 5</DESCRIPTION>
          <TEXT>The Voltage Reference Calibration Register is used to trim the internal voltage reference for the motion comparator threshold level.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>VRCAL4</NAME>
          <DESCRIPTION>Voltage Reference Calibration Bit 4</DESCRIPTION>
          <TEXT>The Voltage Reference Calibration Register is used to trim the internal voltage reference for the motion comparator threshold level.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>VRCAL3</NAME>
          <DESCRIPTION>Voltage Reference Calibration Bit 3</DESCRIPTION>
          <TEXT>The Voltage Reference Calibration Register is used to trim the internal voltage reference for the motion comparator threshold level.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>VRCAL2</NAME>
          <DESCRIPTION>Voltage Reference Calibration Bit 2</DESCRIPTION>
          <TEXT>The Voltage Reference Calibration Register is used to trim the internal voltage reference for the motion comparator threshold level.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>VRCAL1</NAME>
          <DESCRIPTION>Voltage Reference Calibration Bit 1</DESCRIPTION>
          <TEXT>The Voltage Reference Calibration Register is used to trim the internal voltage reference for the motion comparator threshold level.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>VRCAL0</NAME>
          <DESCRIPTION>Voltage Reference Calibration Bit 0</DESCRIPTION>
          <TEXT>The Voltage Reference Calibration Register is used to trim the internal voltage reference for the motion comparator threshold level.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MSVCAL>
      <SCR>
        <NAME>SCR</NAME>
        <DESCRIPTION>Sensor Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x28</IO_ADDR>
        <MEM_ADDR>0x48</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>SMEN</NAME>
          <DESCRIPTION>Sensor Motion Enable Bit</DESCRIPTION>
          <TEXT>This bit controls the motion sensor interface. The SMEN bit must be written to logic 1 to enable the interface. If the SMEN bit is written to logic 0 the motion sensor interface is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SEN1</NAME>
          <DESCRIPTION>Sensor enable Bit 1</DESCRIPTION>
          <TEXT>These bits control the sensor interface stage, as described in the datasheet</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SEN0</NAME>
          <DESCRIPTION>Sensor enable Bit 0</DESCRIPTION>
          <TEXT>These bits control the sensor interface stage, as described in the datasheet</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SMS</NAME>
          <DESCRIPTION>Sensor Measurement Start Bit</DESCRIPTION>
          <TEXT>This bit start the measurement of the selected sensor interface stage.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCR>
      <SCCR>
        <NAME>SCCR</NAME>
        <DESCRIPTION>Sensor Capacitor Control Register</DESCRIPTION>
        <TEXT>This register selects the input channel of the capacitor multiplexer output.</TEXT>
        <IO_ADDR>0x29</IO_ADDR>
        <MEM_ADDR>0x49</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT4>
          <NAME>SCCS2</NAME>
          <DESCRIPTION>Sensor Capacitor Channel Select Bit2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCCS1</NAME>
          <DESCRIPTION>Sensor Capacitor Channel Select Bit1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCCS0</NAME>
          <DESCRIPTION>Sensor Capacitor Channel Select Bit0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SRCC1</NAME>
          <DESCRIPTION>Sensor Reference Charge Current Bit1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SRCC0</NAME>
          <DESCRIPTION>Sensor Reference Charge Current Bit0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCCR>
      <SVCR>
        <NAME>SVCR</NAME>
        <DESCRIPTION>Sensor Voltage Control Register</DESCRIPTION>
        <TEXT>This register controlls different settings of the Voltage interface.</TEXT>
        <IO_ADDR>0x27</IO_ADDR>
        <MEM_ADDR>0x47</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT4>
          <NAME>SVCS4</NAME>
          <DESCRIPTION>Sensor Voltage Channel Select Bit4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SVCS3</NAME>
          <DESCRIPTION>Sensor Voltage Channel Select Bit3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SVCS2</NAME>
          <DESCRIPTION>Sensor Voltage Channel Select Bit2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SVCS1</NAME>
          <DESCRIPTION>Sensor Voltage Channel Select Bit1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SVCS0</NAME>
          <DESCRIPTION>Sensor Voltage Channel Select Bit0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SVCR>
      <SIMSK>
        <NAME>SIMSK</NAME>
        <DESCRIPTION>Sensor Interrupt Mask register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x61</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT0>
          <NAME>MSIE</NAME>
          <DESCRIPTION>Motion Sensor Interrupt Enable Bit</DESCRIPTION>
          <TEXT>Writing MSIE to one enables a motion interrupt if the I bit in SREG is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SIMSK>
      <SSFR>
        <NAME>SSFR</NAME>
        <DESCRIPTION>Sensor Status + Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x19</IO_ADDR>
        <MEM_ADDR>0x39</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>MSENO</NAME>
          <DESCRIPTION>Motion Sensor Output </DESCRIPTION>
          <TEXT>This bit reads the MSENO - signal of motion sensor. This bit is set when the sensor has detected that it is in motion.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MSENF</NAME>
          <DESCRIPTION>Motion Sensor Flag</DESCRIPTION>
          <TEXT>This flag is set when a rising edge occurs at the MSENO output signal. MSENF is automatically cleared when the motion sensor Interrupt Vector is executed. Alternatively, MSENF can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SSFR>
      <TSCR>
        <NAME>TSCR</NAME>
        <DESCRIPTION>Temperature Sensor Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x64</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT0>
          <NAME>TSSD</NAME>
          <DESCRIPTION>Temperature Sensor Shutdown mode Disable </DESCRIPTION>
          <TEXT>This bit control the temperature shutdown mode. The TSSD bit must be written to logic zero to enable the shutdown mode. The temperature shutdown mode is disable, if the TSSD bit is set by writing a logic one to the bit. This mode is enabled after a power-on reset or an internal reset.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TSCR>
    </SENSOR_INTERFACE>
    <SPI>
      <LIST>[SPDR:SPSR:SPCR]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID>SPI_01</ID>
      <TEXT>The Serial Peripheral Interface (SPI) allows high-speed synchronous data transfer between the device and peripheral devices or between several AVR devices. The SPI includes the following features: &#x2022; Full-duplex, 3-wire Synchronous Data Transfer &#x2022; Master or Slave Operation &#x2022; LSB First or MSB First Data Transfer &#x2022; Seven Programmable Bit Rates &#x2022; End of Transmission Interrupt Flag &#x2022; Write Collision Flag Protection &#x2022; Wake-up from Idle Mode &#x2022; Double Speed (CK/2) Master SPI Mode</TEXT>
      <SPDR>
        <NAME>SPDR</NAME>
        <DESCRIPTION>SPI Data Register</DESCRIPTION>
        <TEXT>The SPI Data Register is a read/write register used for data transfer between the register file and the SPI Shift register. Writing to the register initiates data transmission. Reading the register causes the Shift Register Receive buffer to be read.</TEXT>
        <IO_ADDR>0x2E</IO_ADDR>
        <MEM_ADDR>0x4E</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <READ_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SPDR7</NAME>
          <DESCRIPTION>SPI Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SPDR6</NAME>
          <DESCRIPTION>SPI Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SPDR5</NAME>
          <DESCRIPTION>SPI Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SPDR4</NAME>
          <DESCRIPTION>SPI Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SPDR3</NAME>
          <DESCRIPTION>SPI Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SPDR2</NAME>
          <DESCRIPTION>SPI Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SPDR1</NAME>
          <DESCRIPTION>SPI Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPDR0</NAME>
          <DESCRIPTION>SPI Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPDR>
      <SPSR>
        <NAME>SPSR</NAME>
        <DESCRIPTION>SPI Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x2D</IO_ADDR>
        <MEM_ADDR>0x4D</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SPIF</NAME>
          <DESCRIPTION>SPI Interrupt Flag</DESCRIPTION>
          <TEXT>When a serial transfer is complete, the SPIF bit is set (one) and an interrupt is generated if SPIE in SPCR is set (one) and global interrupts are enabled. If SS is an input and is driven low when the SPI is in master mode, this will also set the SPIF flag. SPIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, the SPIF bit is cleared by first reading the SPI status register when SPIF is set (one), then accessing the SPI Data Register (SPDR).</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>WCOL</NAME>
          <DESCRIPTION>Write Collision Flag</DESCRIPTION>
          <TEXT>The WCOL bit is set if the SPI data register (SPDR) is written during a data transfer. The WCOL bit (and the SPIF bit) are cleared (zero) by first reading the SPI Status Register when WCOL is set (one), and then accessing the SPI Data Register.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT0>
          <NAME>SPI2X</NAME>
          <DESCRIPTION>Double SPI Speed Bit</DESCRIPTION>
          <TEXT>When this bit is written logic one the SPI speed (SCK Frequency) will be doubled when the SPI is in master mode (see Table 71). This means that the minimum SCK period will be 2 CPU clock periods. When the SPI is configured as Slave, the SPI is only guaranteed to work at f ck / 4 or lower. The SPI interface on the ATmega104 is also used for program memory and EEPROM downloading or uploading. See page 253 for serial programming and verification.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPSR>
      <SPCR>
        <NAME>SPCR</NAME>
        <DESCRIPTION>SPI Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x2C</IO_ADDR>
        <MEM_ADDR>0x4C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SPIE</NAME>
          <DESCRIPTION>SPI Interrupt Enable</DESCRIPTION>
          <TEXT>This bit causes the SPI interrupt to be executed if SPIF bit in the SPSR register is set and the global interrupts are enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SPE</NAME>
          <DESCRIPTION>SPI Enable</DESCRIPTION>
          <TEXT>When the SPE bit is set (one), the SPI is enabled. This bit must be set to enable any SPI operations.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DORD</NAME>
          <DESCRIPTION>Data Order</DESCRIPTION>
          <TEXT>When the DORD bit is set (one), the LSB of the data word is transmitted first. When the DORD bit is cleared (zero), the MSB of the data word is transmitted first.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>MSTR</NAME>
          <DESCRIPTION>Master/Slave Select</DESCRIPTION>
          <TEXT>This bit selects Master SPI mode when set (one), and Slave SPI mode when cleared (zero). If SS is configured as an input and is driven low while MSTR is set, MSTR will be cleared, and SPIF in SPSR will become set. The user will then have to set MSTR to re-enable SPI master mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CPOL</NAME>
          <DESCRIPTION>Clock polarity</DESCRIPTION>
          <TEXT>When this bit is set (one), SCK is high when idle. When CPOL is cleared (zero), SCK is low when idle. Refer to Figure 36 and Figure 37 for additional information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CPHA</NAME>
          <DESCRIPTION>Clock Phase</DESCRIPTION>
          <TEXT>Refer to Figure 36 or Figure 37 for the functionality of this bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SPR1</NAME>
          <DESCRIPTION>SPI Clock Rate Select 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPR0</NAME>
          <DESCRIPTION>SPI Clock Rate Select 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_SCK_RATE_3BIT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPCR>
    </SPI>
    <CPU>
      <LIST>[CLKPR:CMCR:CMSR:CMIMR:FRCCAL:SRCCAL:VMCSR:SREG:SPH:SPL:SPMCSR:MCUCR:MCUSR:SMCR:GPIOR2:GPIOR1:GPIOR0]</LIST>
      <LINK>[SPH:SPL]</LINK>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT/>
      <CLKPR>
        <NAME>CLKPR</NAME>
        <DESCRIPTION>Clock Prescaler Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x3C</IO_ADDR>
        <MEM_ADDR>0x5C</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>CLPCE</NAME>
          <DESCRIPTION>Clock Prescaler Change Enable Bit</DESCRIPTION>
          <TEXT>The CLPCE bit must be written to logic one to enable change of the CLTPS[2..0] bits and CLKPS[2..0] bits. The CLPCE bit is only updated when the other bits in CLPR are simultaneously written to zero. CLPCE is cleared by hardware four cycles after it is written or when CLTPS[2..0] bits and CLKPS[2..0] bits are written. Rewriting the CLPCE bit within this time-out period does neither extend the time-out period, nor clear the CLPCE bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT5>
          <NAME>CLTPS2</NAME>
          <DESCRIPTION>Clock Timer Prescaler Select Bit 2 </DESCRIPTION>
          <TEXT>These bits select the timer output clock (CLT) of the Timer Clock Prescaler.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CLTPS1</NAME>
          <DESCRIPTION>Clock Timer Prescaler Select Bit 1</DESCRIPTION>
          <TEXT>These bits select the timer output clock (CLT) of the Timer Clock Prescaler.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CLTPS0</NAME>
          <DESCRIPTION>Clock Timer Prescaler Select Bit 0</DESCRIPTION>
          <TEXT>These bits select the timer output clock (CLT) of the Timer Clock Prescaler.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CLKPS2</NAME>
          <DESCRIPTION>Clock system Prescaler Select Bit 2</DESCRIPTION>
          <TEXT>These bits select the system output clock (CLK).of the System Clock Prescaler.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CLKPS1</NAME>
          <DESCRIPTION>Clock system Prescaler Select Bit 1</DESCRIPTION>
          <TEXT>These bits select the system output clock (CLK).of the System Clock Prescaler.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CLKPS0</NAME>
          <DESCRIPTION>Clock system Prescaler Select Bit 0</DESCRIPTION>
          <TEXT>These bits select the system output clock (CLK).of the System Clock Prescaler.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </CLKPR>
      <CMCR>
        <NAME>CMCR</NAME>
        <DESCRIPTION>Clock Management Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x0F</IO_ADDR>
        <MEM_ADDR>0x2F</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>CMCCE</NAME>
          <DESCRIPTION>Clock Management Control Change Enable Bit</DESCRIPTION>
          <TEXT>The CMCCE bit must be written to logic one to enable change of the CMM bits, CO32E bit, SRCD bit, CCS bit and ECINS bit. The CMCCE bit is only updated when the other bits in CMCR are simultaneously written to zero. CMCCE is cleared by hardware four cycles after it is written or when CMM, CCS and ECINS bits are written. Rewriting the CMCCE bit within this time-out period does neither extend the time-out period, nor clear the CMCCE bit.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT5>
          <NAME>ECINS</NAME>
          <DESCRIPTION>External Clock Input Select Bit</DESCRIPTION>
          <TEXT>This bit selects one of the two external clock input [PC0(ECIN0) or PD4(ECIN1)]. The ECINS bit must be written to logic one to enable the ECIN1 clock input, and if the ECINS bit is written to logic zero, then ECIN0 clock input is enable.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CCS</NAME>
          <DESCRIPTION>Core Clock Select Bit</DESCRIPTION>
          <TEXT>This bit select between FRC-oscillator clock and all other clock sources. The CCS bit must be written to logic one to enable the mode there is selected with the CMM[1..0] bits, and if the CCS bit is written to logic zero, the FRC-oscillator clock is enable.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CMONEN</NAME>
          <DESCRIPTION>Clock Monitoring Enable</DESCRIPTION>
          <TEXT>This bit controls the clock monitoring. The CMONEN bit must be written to logic one to enable the clock monitoring, if the CMONEN bit is written to logic zero, clock monitoring is always disabled. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SRCD</NAME>
          <DESCRIPTION>Slow RC-oscillator Disable Bit</DESCRIPTION>
          <TEXT>This bit controls the SRC oscillator used as clock source for the WatchDog (also called as WDRC). The SRCD bit must be written to logic one to disable (stop) the SRC, and if the SRCD bit is written to logic zero, the SRC is always enabled (running). The SRC-oscillator can only be disabled, if the fuse bit WDRCON is programmed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CMM1</NAME>
          <DESCRIPTION>Clock Management Mode Bits 1</DESCRIPTION>
          <TEXT>These bits select the input clock source (CL) of the System Clock Prescaler </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CMM0</NAME>
          <DESCRIPTION>Clock Management Mode Bits 0</DESCRIPTION>
          <TEXT>These bits select the input clock source (CL) of the System Clock Prescaler </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </CMCR>
      <CMSR>
        <NAME>CMSR</NAME>
        <DESCRIPTION>Clock Management Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x10</IO_ADDR>
        <MEM_ADDR>0x30</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT0>
          <NAME>ECF</NAME>
          <DESCRIPTION>External Clock input Flag Bit</DESCRIPTION>
          <TEXT>This bit is set if clock monitoring circuit detect break down of the selected external input clock (ECIN0 or ECIN1). ECF is automatically cleared when the clock monitoring Interrupt Vector is executed. Alternatively, ECF can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </CMSR>
      <CMIMR>
        <NAME>CMIMR</NAME>
        <DESCRIPTION>Clock Management Interrupt Mask Register </DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x3B</IO_ADDR>
        <MEM_ADDR>0x5B</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT0>
          <NAME>ECIE</NAME>
          <DESCRIPTION>External Clock input Interrupt Enable Bit</DESCRIPTION>
          <TEXT>Writing ECIE to one enables the clock monitoring Interrupt Vector if the I bit in SREG is set. Writing ECIE to zero disables the interrupt. The corresponding Interrupt Vector is executed when the ECF Flag, located in CMSR, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </CMIMR>
      <FRCCAL>
        <NAME>FRCCAL</NAME>
        <DESCRIPTION>FRC-Oscillator Calibration Register </DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x66</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT5>
          <NAME>FCAL5</NAME>
          <DESCRIPTION>FRC-Oscillator Calibration Register Bit5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>FCAL4</NAME>
          <DESCRIPTION>FRC-Oscillator Calibration Register Bit4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>FCAL3</NAME>
          <DESCRIPTION>FRC-Oscillator Calibration Register Bit3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>FCAL2</NAME>
          <DESCRIPTION>FRC-Oscillator Calibration Register Bit2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>FCAL1</NAME>
          <DESCRIPTION>FRC-Oscillator Calibration Register Bit1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>FCAL0</NAME>
          <DESCRIPTION>FRC-Oscillator Calibration Register Bit0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </FRCCAL>
      <SRCCAL>
        <NAME>SRCCAL</NAME>
        <DESCRIPTION>SRC-Oscillator Calibration Register </DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x65</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SCAL7</NAME>
          <DESCRIPTION>SRC-Oscillator Calibration Register Bit7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCAL6</NAME>
          <DESCRIPTION>SRC-Oscillator Calibration Register Bit6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCAL5</NAME>
          <DESCRIPTION>SRC-Oscillator Calibration Register Bit5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCAL4</NAME>
          <DESCRIPTION>SRC-Oscillator Calibration Register Bit4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCAL3</NAME>
          <DESCRIPTION>SRC-Oscillator Calibration Register Bit3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCAL2</NAME>
          <DESCRIPTION>SRC-Oscillator Calibration Register Bit2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCAL1</NAME>
          <DESCRIPTION>SRC-Oscillator Calibration Register Bit1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCAL0</NAME>
          <DESCRIPTION>SRC-Oscillator Calibration Register Bit0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SRCCAL>
      <VMCSR>
        <NAME>VMCSR</NAME>
        <DESCRIPTION>Voltage Monitor Control and Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x16</IO_ADDR>
        <MEM_ADDR>0x36</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>BODLS</NAME>
          <DESCRIPTION>Brown-Out Detection Level Select Bit</DESCRIPTION>
          <TEXT>This bit select the monitoring level of the programmable Brown-out detection circuit. BODLS=0 - 1.8V; BODLS=1 - 2.0V</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>BODPD</NAME>
          <DESCRIPTION>Brown-Out Detection on Power-Down Bit</DESCRIPTION>
          <TEXT>This bit enable the Brown-out detection circuit on the power-down mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>VMF</NAME>
          <DESCRIPTION>Voltage Monitor Flag</DESCRIPTION>
          <TEXT>This flag is set if the supervised voltage level is below this programmable threshold. VMF is automatically cleared when the Voltage monitor Interrupt Vector is executed. Alternatively, VMF can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>VMIM</NAME>
          <DESCRIPTION>Voltage Monitor Interrupt Mask Bit</DESCRIPTION>
          <TEXT>Writing VMIM to one enables a VM interrupt if the I bit in SREG is set. Writing VMIM to zero disables the interrupt. The corresponding Interrupt Vector is executed when the VMF Flag, located in LFFR, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>VMLS2</NAME>
          <DESCRIPTION>Voltage Monitor Level Select Bit 2</DESCRIPTION>
          <TEXT>The bits VMLS2, VMLS1 and VMLS0 select the monitoring level of the programmable voltage monitor circuit</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>VMLS1</NAME>
          <DESCRIPTION>Voltage Monitor Level Select Bit 1</DESCRIPTION>
          <TEXT>The bits VMLS2, VMLS1 and VMLS0 select the monitoring level of the programmable voltage monitor circuit</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>VMLS0</NAME>
          <DESCRIPTION>Voltage Monitor Level Select Bit 0</DESCRIPTION>
          <TEXT>The bits VMLS2, VMLS1 and VMLS0 select the monitoring level of the programmable voltage monitor circuit</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>VMEN</NAME>
          <DESCRIPTION>Voltage Monitor Enable Bit</DESCRIPTION>
          <TEXT>This bit control the VM. The VMEN bit must be written to logic one to enable the Voltage Monitor, and if the VMEN bit is written to logic zero, the VM is disable.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </VMCSR>
      <SREG>
        <NAME>SREG</NAME>
        <DESCRIPTION>Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x3F</IO_ADDR>
        <MEM_ADDR>0x5F</MEM_ADDR>
        <ICON>io_sreg.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>I</NAME>
          <DESCRIPTION>Global Interrupt Enable</DESCRIPTION>
          <TEXT>The global interrupt enable bit must be set (one) for the interrupts to be enabled. The individual interrupt enable control is then performed in separate control registers. If the global interrupt enable bit is cleared (zero), none of the interrupts are enabled independent of the individual interrupt enable settings. The I-bit is cleared by hardware after an interrupt has occurred, and is set by the RETI instruction to enable subsequent interrupts.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T</NAME>
          <DESCRIPTION>Bit Copy Storage</DESCRIPTION>
          <TEXT>The bit copy instructions BLD (Bit LoaD) and BST (Bit STore) use the T bit as source and destination for the operated bit. A bit from a register in the register file can be copied into T by the BST instruction, and a bit in T can be copied into a bit in a register in the register file by the BLD instruction.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>H</NAME>
          <DESCRIPTION>Half Carry Flag</DESCRIPTION>
          <TEXT>The half carry flag H indicates a half carry in some arithmetic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>S</NAME>
          <DESCRIPTION>Sign Bit</DESCRIPTION>
          <TEXT>The S-bit is always an exclusive or between the negative flag N and the two&#x2019;s complement overflow flag V. See the Instruc-tion Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>V</NAME>
          <DESCRIPTION>Two's Complement Overflow Flag</DESCRIPTION>
          <TEXT>The two&#x2019;s complement overflow flag V supports two&#x2019;s complement arithmetics. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>N</NAME>
          <DESCRIPTION>Negative Flag</DESCRIPTION>
          <TEXT>The negative flag N indicates a negative result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Z</NAME>
          <DESCRIPTION>Zero Flag</DESCRIPTION>
          <TEXT>The zero flag Z indicates a zero result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>C</NAME>
          <DESCRIPTION>Carry Flag</DESCRIPTION>
          <TEXT>The carry flag C indicates a carry in an arithmetic or logic operation. See the Instruction Set Description for detailed information. Note that the status register is not automatically stored when entering an interrupt routine and restored when returning from an interrupt routine. This must be handled by software.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SREG>
      <SPH>
        <NAME>SPH</NAME>
        <DESCRIPTION>Stack Pointer High</DESCRIPTION>
        <TEXT>The general AVR 16-bit Stack Pointer is effectively built up of two 8-bit registers in the I/O space locations $3E ($5E) and $3D ($5D). As the AT90S4414/8515 supports up to 64 kB external SRAM, all 16-bits are used. The Stack Pointer points to the data SRAM stack area where the Subroutine and Interrupt Stacks are located. This Stack space in the data SRAM must be defined by the program before any subroutine calls are executed or interrupts are enabled. The stack pointer must be set to point above $60. The Stack Pointer is decremented by one when data is pushed onto the Stack with the PUSH instruction, and it is decremented by two when an address is pushed onto the Stack with subroutine calls and interrupts. The Stack Pointer is incremented by one when data is popped from the Stack with the POP instruction, and it is incremented by two when an address is popped from the Stack with return from subroutine RET or return from interrupt R</TEXT>
        <IO_ADDR>0x3E</IO_ADDR>
        <MEM_ADDR>0x5E</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SP15</NAME>
          <DESCRIPTION>Stack pointer bit 15</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SP14</NAME>
          <DESCRIPTION>Stack pointer bit 14</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SP13</NAME>
          <DESCRIPTION>Stack pointer bit 13</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SP12</NAME>
          <DESCRIPTION>Stack pointer bit 12</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SP11</NAME>
          <DESCRIPTION>Stack pointer bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SP10</NAME>
          <DESCRIPTION>Stack pointer bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP9</NAME>
          <DESCRIPTION>Stack pointer bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP8</NAME>
          <DESCRIPTION>Stack pointer bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPH>
      <SPL>
        <NAME>SPL</NAME>
        <DESCRIPTION>Stack Pointer Low</DESCRIPTION>
        <TEXT>The general AVR 16-bit Stack Pointer is effectively built up of two 8-bit registers in the I/O space locations $3E ($5E) and $3D ($5D). As the AT90S4414/8515 supports up to 64 kB external SRAM, all 16-bits are used. The Stack Pointer points to the data SRAM stack area where the Subroutine and Interrupt Stacks are located. This Stack space in the data SRAM must be defined by the program before any subroutine calls are executed or interrupts are enabled. The stack pointer must be set to point above $60. The Stack Pointer is decremented by one when data is pushed onto the Stack with the PUSH instruction, and it is decremented by two when an address is pushed onto the Stack with subroutine calls and interrupts. The Stack Pointer is incremented by one when data is popped from the Stack with the POP instruction, and it is incremented by two when an address is popped from the Stack with return from subroutine RET or return from interrupt </TEXT>
        <IO_ADDR>0x3D</IO_ADDR>
        <MEM_ADDR>0x5D</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SP7</NAME>
          <DESCRIPTION>Stack pointer bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SP6</NAME>
          <DESCRIPTION>Stack pointer bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SP5</NAME>
          <DESCRIPTION>Stack pointer bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SP4</NAME>
          <DECRIPTION>Stack pointer bit 4</DECRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SP3</NAME>
          <DESCRIPTION>Stack pointer bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SP2</NAME>
          <DESCRIPTION>Stack pointer bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP1</NAME>
          <DESCRIPTION>Stack pointer bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP0</NAME>
          <DESCRIPTION>Stack pointer bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPL>
      <SPMCSR>
        <NAME>SPMCSR</NAME>
        <DESCRIPTION>Store Program Memory Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x37</IO_ADDR>
        <MEM_ADDR>0x57</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SPMIE</NAME>
          <DESCRIPTION>SPM Interrupt Enable</DESCRIPTION>
          <TEXT>When the SPMIE bit is written to one, and the I-bit in the Status Register is set (one), the SPM ready interrupt will be enabled. The SPM ready Interrupt will be executed as long as the SPMEN bit in the SPMCR register is cleared.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>RWWSB</NAME>
          <DESCRIPTION>Read-While-Write Section Busy</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT4>
          <NAME>RWWSRE</NAME>
          <DESCRIPTION>Read-While-Write section read enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>BLBSET</NAME>
          <DESCRIPTION>Boot Lock Bit Set</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles sets Boot Lock bits, according to the data in R0. The data in R1 and the address in the Z pointer are ignored. The BLBSET bit will automatically be cleared upon completion of the lock bit set, or if no SPM instruction is executed within four clock cycles.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PGWRT</NAME>
          <DESCRIPTION>Page Write</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles executes page write, with the data stored in the temporary buffer. The page address is taken from the high part of the Z pointer. The data in R1 and R0 are ignored. The PGWRT bit will auto-clear upon completion of a page write, or if no SPM instruction is executed within four clock cycles. The CPU is halted during the entire page write operation if the NRWW section is addressed.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PGERS</NAME>
          <DESCRIPTION>Page Erase</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles executes page erase. The page address is taken from the high part of the Z pointer. The data in R1 and R0 are ignored. The PGERS bit will auto-clear upon completion of a page erase, or if no SPM instruction is executed within four clock cycles. The CPU is halted during the entire page write operation if the NRWW section is addressed.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SELFPRGEN</NAME>
          <DESCRIPTION>Self Programming Enable</DESCRIPTION>
          <TEXT>The explanation is to long to include here. Please refer to the printed documentation.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPMCSR>
      <MCUCR>
        <NAME>MCUCR</NAME>
        <DESCRIPTION>MCU Control Register</DESCRIPTION>
        <TEXT>The MCU Control Register contains control bits for general MCU functions.</TEXT>
        <IO_ADDR>0x35</IO_ADDR>
        <MEM_ADDR>0x55</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT4>
          <NAME>PUD</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT1>
          <NAME>IVSEL</NAME>
          <DESCRIPTION>Interrupt Vector Select</DESCRIPTION>
          <TEXT>When the IVSEL bit is cleared (zero), the Interrupt Vectors are placed at the start of the Flash memory. When this bit is set (one), the Interrupt Vectors are moved to the beginning of the Boot Loader section of the Flash.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>IVCE</NAME>
          <DESCRIPTION>Interrupt Vector Change Enable</DESCRIPTION>
          <TEXT>The IVCE bit must be written to logic one to enable change of the IVSEL bit. IVCE is cleared by hardware four cycles after it is written or when IVSEL is written.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUCR>
      <MCUSR>
        <NAME>MCUSR</NAME>
        <DESCRIPTION>MCU Status Register</DESCRIPTION>
        <TEXT>The MCU Status Register provides information on which reset source caused a MCU reset.</TEXT>
        <IO_ADDR>0x34</IO_ADDR>
        <MEM_ADDR>0x54</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>TSRF</NAME>
          <DESCRIPTION>Temperature Shutdown Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a temperature shutdown reset occurs and the temperature shutdown funtion is enabled. This bit is reset by a Power-on Reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT3>
          <NAME>WDRF</NAME>
          <DESCRIPTION>Watchdog Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a watchdog reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>BORF</NAME>
          <DESCRIPTION>Brown-out Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a brown-out reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EXTRF</NAME>
          <ALIAS>EXTREF</ALIAS>
          <DESCRIPTION>External Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if an external reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORF</NAME>
          <DESCRIPTION>Power-on reset flag</DESCRIPTION>
          <TEXT>This bit is set if a power-on reset occurs. The bit is reset only by writing a logic zero to the flag. To make use of the reset flags to identify a reset condition, the user should read and then reset the MCUCSR as early as possible in the program. If the register is cleared before another reset occurs, the source of the reset can be found by examining the reset flags.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUSR>
      <SMCR>
        <NAME>SMCR</NAME>
        <DESCRIPTION>Sleep Mode Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x33</IO_ADDR>
        <MEM_ADDR>0x53</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>SM2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SM1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SM0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SE</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SMCR>
      <GPIOR2>
        <NAME>GPIOR2</NAME>
        <DESCRIPTION>General Purpose I/O Register 2</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x2B</IO_ADDR>
        <MEM_ADDR>0x4B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>GPIOR27</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>GPIOR26</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>GPIOR25</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>GPIOR24</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>GPIOR23</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>GPIOR22</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>GPIOR21</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>GPIOR20</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GPIOR2>
      <GPIOR1>
        <NAME>GPIOR1</NAME>
        <DESCRIPTION>General Purpose I/O Register 1</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x2A</IO_ADDR>
        <MEM_ADDR>0x4A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>GPIOR17</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>GPIOR16</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>GPIOR15</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>GPIOR14</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>GPIOR13</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS/>
          <INIT_VAL/>
        </BIT3>
        <BIT2>
          <NAME>GPIOR12</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>GPIOR11</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>GPIOR10</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GPIOR1>
      <GPIOR0>
        <NAME>GPIOR0</NAME>
        <DESCRIPTION>General Purpose I/O Register 0</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x1E</IO_ADDR>
        <MEM_ADDR>0x3E</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>GPIOR07</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>GPIOR06</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>GPIOR05</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>GPIOR04</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>GPIOR03</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS/>
          <INIT_VAL/>
        </BIT3>
        <BIT2>
          <NAME>GPIOR02</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>GPIOR01</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>GPIOR00</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GPIOR0>
    </CPU>
    <LFRX>
      <LIST>[LFRCR:LFCDR:LFRB:LFRR:LFHCR:LFIDCH:LFIDCL:LFIMR:LFFR:LFCALH:LFCALL]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>Low Frequency Receiver</TEXT>
      <LFRCR>
        <NAME>LFRCR</NAME>
        <DESCRIPTION>Low Frequency Receiver Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x82</MEM_ADDR>
        <ICON>register.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>LFCS2</NAME>
          <DESCRIPTION>LF receiver Capacitor Select Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>LFCS1</NAME>
          <DESCRIPTION>LF receiver Capacitor Select Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>LFCS0</NAME>
          <DESCRIPTION>LF receiver Capacitor Select Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>LFRSS</NAME>
          <DESCRIPTION>LF Receiver Sensitivity Select Bit</DESCRIPTION>
          <TEXT>This bit selects the sensitivity level of the LF receiver input channel</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>LFWM1</NAME>
          <DESCRIPTION>LF receiver Wake-up Mode Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>LFWM0</NAME>
          <DESCRIPTION>LF receiver Wake-up Mode Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>LFBM</NAME>
          <DESCRIPTION>LF receiver Burst Mode enable Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>LFEN</NAME>
          <DESCRIPTION>LF receiver Enable Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </LFRCR>
      <LFCDR>
        <NAME>LFCDR</NAME>
        <DESCRIPTION>LF receiver Control und Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x32</IO_ADDR>
        <MEM_ADDR>0x52</MEM_ADDR>
        <ICON>register.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>LFSCE</NAME>
          <DESCRIPTION>LF receiver RSSI Software Capture Enable Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>LFRST</NAME>
          <DESCRIPTION>LF receiver Reset Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT0>
          <NAME>LFDO</NAME>
          <DESCRIPTION>LF receiver Data Output Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </LFCDR>
      <LFRB>
        <NAME>LFRB</NAME>
        <DESCRIPTION>Low Frequency Receive data Buffer</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x36</IO_ADDR>
        <MEM_ADDR>0x56</MEM_ADDR>
        <ICON>register.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>LFRB7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>LFRB6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>LFRB5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>LFRB4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>LFRB3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>LFRB2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>LFRB1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>LFRB0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </LFRB>
      <LFRR>
        <NAME>LFRR</NAME>
        <DESCRIPTION>LF RSSI Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x30</IO_ADDR>
        <MEM_ADDR>0x50</MEM_ADDR>
        <ICON>register.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT6>
          <NAME>LFRR6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>LFRR5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>LFRR4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>LFRR3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>LFRR2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>LFRR1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>LFRR0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </LFRR>
      <LFHCR>
        <NAME>LFHCR</NAME>
        <DESCRIPTION>LF Header Compare Register</DESCRIPTION>
        <TEXT>The LFHCR contains the 7-bit data of the Header compare value.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x83</MEM_ADDR>
        <ICON>register.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT6>
          <NAME>LFHCR6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>LFHCR5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>LFHCR4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>LFHCR3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>LFHCR2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>LFHCR1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>LFHCR0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </LFHCR>
      <LFIDCH>
        <NAME>LFIDCH</NAME>
        <DESCRIPTION>LF ID Compare Register High</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x85</MEM_ADDR>
        <ICON>register.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>LFIDCH_15</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>LFIDCH_14</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>LFIDCH_13</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>LFIDCH_12</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>LFIDCH_11</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>LFIDCH_10</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>LFIDCH_9</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>LFIDCH_8</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </LFIDCH>
      <LFIDCL>
        <NAME>LFIDCL</NAME>
        <DESCRIPTION>LF ID Compare Register Low</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x84</MEM_ADDR>
        <ICON>register.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>LFIDCL_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>LFIDCL_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>LFIDCL_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>LFIDCL_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>LFIDCL_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>LFIDCL_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>LFIDCL_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>LFIDCL_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </LFIDCL>
      <LFIMR>
        <NAME>LFIMR</NAME>
        <DESCRIPTION>Low Frequency Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x81</MEM_ADDR>
        <ICON>register.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>LFEIM</NAME>
          <DESCRIPTION>LF receiver End of data Interrupt Mask bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>LFBIM</NAME>
          <DESCRIPTION>LF receiver data Buffer Interrupt Mask bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>LFWIM</NAME>
          <DESCRIPTION>LF receiver Wake-up Interrupt Mask bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </LFIMR>
      <LFFR>
        <NAME>LFFR</NAME>
        <DESCRIPTION>Low Frequency Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x18</IO_ADDR>
        <MEM_ADDR>0x38</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>LFRF</NAME>
          <DESCRIPTION>LF receiver Rssi data Flag</DESCRIPTION>
          <TEXT>This flag is set when the 7-bit field strength measurement value of the digital AGC has loaded to the RSSI data register (LFRR).</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>LFEDF</NAME>
          <DESCRIPTION>LF receiver End of data Flag</DESCRIPTION>
          <TEXT>This flag is set when the data decoder has detected a bit error of the modulation data stream. LFEF is automatically cleared when the LF receiver end of burst Interrupt Vector is executed. Alternatively, LFEF can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>LFBF</NAME>
          <DESCRIPTION>LF receiver data Buffer full Flag</DESCRIPTION>
          <TEXT>This flag is set when the on-chip manchester decoder has loaded a decoded 8-bit data frame to the receive buffer. LFBF is automatically cleared when the LF receiver Buffer Full Interrupt Vector is executed. Alternatively, LFBF can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>LFWPF</NAME>
          <DESCRIPTION>LF receiver Wake-up Flag</DESCRIPTION>
          <TEXT>This flag is set when LF receiver is wake-up. LFWPF is automatically cleared when the LF receiver Wake-up Interrupt Vector is executed. Alternatively, LFWPF can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </LFFR>
      <LFCALH>
        <NAME>LFCALH</NAME>
        <DESCRIPTION>LF Calibration Register High Byte</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x87</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>LFCAL_15</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>LFCAL_14</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>LFCAL_13</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>LFCAL_12</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>LFCAL_11</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>LFCAL_10</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>LFCAL_09</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>LFCAL_08</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </LFCALH>
      <LFCALL>
        <NAME>LFCALL</NAME>
        <DESCRIPTION>LF Calibration Register Low Byte</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x86</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>LFCAL_07</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>LFCAL_06</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>LFCAL_05</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>LFCAL_04</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>LFCAL_03</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>LFCAL_02</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>LFCAL_01</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>LFCAL_00</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </LFCALL>
    </LFRX>
    <EXTERNAL_INTERRUPT>
      <LIST>[EICRA:EIMSK:EIFR:PCMSK0:PCMSK1:PCMSK2:PCIFR:PCICR]</LIST>
      <LINK/>
      <ICON>io_ext.bmp</ICON>
      <ID/>
      <TEXT>The external interrupts are triggered by the INT7:0 pins. Observe that, if enabled, the interrupts will trigger even if the INT7:0 pins are configured as outputs. This feature provides a way of generating a software interrupt. The external inter-rupts can be triggered by a falling or rising edge or a low level. This is set up as indicated in the specification for the Exter-nal Interrupt Control Registers - EICRA (INT3:0) and EICRB (INT7:4). When the external interrupt is enabled and is configured as level triggered, the interrupt will trigger as long as the pin is held low. Note that recognition of falling or rising edge interrupts on INT7:4 requires the presence of an I/O clock, described in &#x201C;Clock Systems and their Distribution&#x201D; on page 29. Low level interrupts and the edge interrupt on INT3:0 are detected asynchronously. This implies that these inter-rupts can be used for waking the part also from sleep modes other than Idle mode. The I/O clock is halted in all sleep modes except Idle mode. Note that if a level triggered interrupt is used for wake-up from Power Down Mode, the changed level must be held for some time to wake up the MCU. This makes the MCU less sensitive to noise. The changed level is sampled twice by the watchdog oscillator clock. The period of the watchdog oscillator is 1 &#xB5;s (nominal) at 5.0V and 25&#xB0;C. The frequency of the watchdog oscillator is voltage dependent as shown in the Electrical Characteristics section. The MCU will wake up if the input has the required level during this sampling or if it is held until the end of the start-up time. The start-up time is defined by the SUT fuses as described in &#x201C;Clock Systems and their Distribution&#x201D; on page 29. If the level is sampled twice by the watchdog oscillator clock but disappears before the end of the start-up time, the MCU will still wake up, but no interrupt will be generated. The required level must be held long enough for the MCU to complete the wake up to trigger the level interrup</TEXT>
      <EICRA>
        <NAME>EICRA</NAME>
        <DESCRIPTION>External Interrupt Control Register </DESCRIPTION>
        <TEXT>The External Interrupt Control Register A contains control bits for interrupt sense control.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x69</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>ISC11</NAME>
          <DESCRIPTION>External Interrupt Sense Control 1 Bit 1 </DESCRIPTION>
          <TEXT>The External Interrupt 1 is activated by the external pin INT1 if the SREG I-flag and the corresponding interrupt mask are set.The value on the INT1 pin is sampled before detecting edges.If edge or toggle interrupt is selected,pulses that last longer than one clock period will generate an interrupt.Shorter pulses are not guaranteed to generate an interrupt.If low level interrupt is selected,the lowlevel must be held until the completion of the currently executing instruction to generate an interrupt.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ISC10</NAME>
          <DESCRIPTION>External Interrupt Sense Control 1 Bit 0</DESCRIPTION>
          <TEXT>The External Interrupt 1 is activated by the external pin INT1 if the SREG I-flag and the corresponding interrupt mask are set.The value on the INT1 pin is sampled before detecting edges.If edge or toggle interrupt is selected,pulses that last longer than one clock period will generate an interrupt.Shorter pulses are not guaranteed to generate an interrupt.If low level interrupt is selected,the lowlevel must be held until the completion of the currently executing instruction to generate an interrupt.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ISC01</NAME>
          <DESCRIPTION>External Interrupt Sense Control 0 Bit 1 </DESCRIPTION>
          <TEXT>The External Interrupt 0 is activated by the external pin INT0 if the SREG I-flag and the corresponding interrupt mask are set.The value on the INT0 pin is sampled before detecting edges.If edge or toggle interrupt is selected,pulses that last longer than one clock period will generate an interrupt.Shorter pulses are not guaranteed to generate an interrupt.If low level interrupt is selected,the lowlevel must be held until the completion of the currently executing instruction to generate an interrupt.      </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ISC00</NAME>
          <DESCRIPTION>External Interrupt Sense Control 0 Bit 0</DESCRIPTION>
          <TEXT>The External Interrupt 0 is activated by the external pin INT0 if the SREG I-flag and the corresponding interrupt mask are set.The value on the INT0 pin is sampled before detecting edges.If edge or toggle interrupt is selected,pulses that last longer than one clock period will generate an interrupt.Shorter pulses are not guaranteed to generate an interrupt.If low level interrupt is selected,the lowlevel must be held until the completion of the currently executing instruction to generate an interrupt.      </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EICRA>
      <EIMSK>
        <NAME>EIMSK</NAME>
        <DESCRIPTION>External Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x24</IO_ADDR>
        <MEM_ADDR>0x44</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>INT1</NAME>
          <DESCRIPTION>External Interrupt Request 1 Enable</DESCRIPTION>
          <TEXT>When the INT1 bit is set (one)and the I-bit in the Status Register (SREG)is set (one),the external pin interrupt is enabled. The Interrupt Sense Control1 bits 1/0 (ISC11 and ISC10)in the External Interrupt Control Register A (EICRA)define whether the external interrupt is activated on rising and/or falling edge of the INT1 pin or level sensed.Activity on the pin will cause an interrupt request even if INT1 is configured as an output.The corresponding interrupt of External Interrupt Request 1 is executed from the INT1 interrupt vector.    </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>INT0</NAME>
          <DESCRIPTION>External Interrupt Request 0 Enable</DESCRIPTION>
          <TEXT>When the INT0 bit is set (one)and the I-bit in the Status Register (SREG)is set (one),the external pin interrupt is enabled. The Interrupt Sense Control0 bits 1/0 (ISC01 and ISC00)in the External Interrupt Control Register A (EICRA)define whether the external interrupt is activated on rising and/or falling edge of the INT0 pin or level sensed.Activity on the pin will cause an interrupt request even if INT0 is configured as an output.The corresponding interrupt of External Interrupt Request 0 is executed from the INT0 interrupt vector.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EIMSK>
      <EIFR>
        <NAME>EIFR</NAME>
        <DESCRIPTION>External Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x1D</IO_ADDR>
        <MEM_ADDR>0x3D</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>INTF1</NAME>
          <DESCRIPTION>External Interrupt Flag 1</DESCRIPTION>
          <TEXT>When an edge or logic change on the INT1 pin triggers an interrupt request,INTF1 becomes set (one).If the I-bit in SREG and the INT1 bit in EIMSK are set (one),the MCU will jump to the corresponding interrupt vector.The flag is cleared when the interrupt routine is executed.Alternatively,the flag can be cleared by writing a logical one to it.This flag is always cleared when INT0 is configured as a level interrupt.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>INTF0</NAME>
          <DESCRIPTION>External Interrupt Flag 0</DESCRIPTION>
          <TEXT>When an edge or logic change on the INT0 pin triggers an interrupt request,INTF0 becomes set (one).If the I-bit in SREG and the INT0 bit in EIMSK are set (one),the MCU will jump to the corresponding interrupt vector.The flag is cleared when the interrupt routine is executed.Alternatively,the flag can be cleared by writing a logical one to it.This flag is always cleared when INT0 is configured as a level interrupt.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EIFR>
      <PCMSK0>
        <NAME>PCMSK0</NAME>
        <DESCRIPTION>Pin Change Mask Register 0</DESCRIPTION>
        <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin.If PCINT7..0 is set and the PCIE0 bit in EIMSK is set,pin change interrupt is enabled on the corresponding I/O pin.If PCINT7..0 is cleared,pin change interrupt on the corresponding I/O pin is disabled.      </TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PCINT7</NAME>
          <DESCRIPTION>Pin Change Enable Mask 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PCINT6</NAME>
          <DESCRIPTION>Pin Change Enable Mask 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCINT5</NAME>
          <DESCRIPTION>Pin Change Enable Mask 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCINT4</NAME>
          <DESCRIPTION>Pin Change Enable Mask 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PCINT3</NAME>
          <DESCRIPTION>Pin Change Enable Mask 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCINT2</NAME>
          <DESCRIPTION>Pin Change Enable Mask 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCINT1</NAME>
          <DESCRIPTION>Pin Change Enable Mask 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCINT0</NAME>
          <DESCRIPTION>Pin Change Enable Mask 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCMSK0>
      <PCMSK1>
        <NAME>PCMSK1</NAME>
        <DESCRIPTION>Pin Change Mask Register 1</DESCRIPTION>
        <TEXT>Each PCINT10..8 bit selects whether pin change interrupt is enabled on the corresponding I/O pin.If PCINT10..8 is set and the PCIE0 bit in EIMSK is set,pin change interrupt is enabled on the corresponding I/O pin.If PCINT10..8 is cleared,pin change interrupt on the corresponding I/O pin is disabled.      </TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>PCINT10</NAME>
          <DESCRIPTION>Pin Change Enable Mask 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCINT9</NAME>
          <DESCRIPTION>Pin Change Enable Mask 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCINT8</NAME>
          <DESCRIPTION>Pin Change Enable Mask 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCMSK1>
      <PCMSK2>
        <NAME>PCMSK2</NAME>
        <DESCRIPTION>Pin Change Mask Register 2</DESCRIPTION>
        <TEXT>Each PCINT23..16-bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT23..16 is set and the PCIE2 bit in PCICR is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT23..16 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PCINT23</NAME>
          <DESCRIPTION>Pin Change Enable Mask 23</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PCINT22</NAME>
          <DESCRIPTION>Pin Change Enable Mask 22</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCINT21</NAME>
          <DESCRIPTION>Pin Change Enable Mask 21</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCINT20</NAME>
          <DESCRIPTION>Pin Change Enable Mask 20</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PCINT19</NAME>
          <DESCRIPTION>Pin Change Enable Mask 19</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCINT18</NAME>
          <DESCRIPTION>Pin Change Enable Mask 18</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCINT17</NAME>
          <DESCRIPTION>Pin Change Enable Mask 17</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCINT16</NAME>
          <DESCRIPTION>Pin Change Enable Mask 16</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCMSK2>
      <PCIFR>
        <NAME>PCIFR</NAME>
        <DESCRIPTION>Pin Change Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x17</IO_ADDR>
        <MEM_ADDR>0x37</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>PCIF2</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag 2</DESCRIPTION>
          <TEXT>When a logic change on any PCINT23..16 pin triggers an interrupt request, PCIF2 becomes set (one). If the I-bit in SREG and the PCIE2 bit in PCICR are set (one), the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCIF1</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag 1</DESCRIPTION>
          <TEXT>When a logic change on any PCINT14..8 pin triggers an interrupt request, PCIF1 becomes set (one). If the I-bit in SREG and the PCIE1 bit in PCICR are set (one), the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCIF0</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag 0</DESCRIPTION>
          <TEXT>When a logic change on any PCINT7..0 pin triggers an interrupt request, PCIF0 becomes set (one). If the I-bit in SREG and the PCIE0 bit in PCICR are set (one), the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCIFR>
      <PCICR>
        <NAME>PCICR</NAME>
        <DESCRIPTION>Pin Change Interrupt Control Register </DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x23</IO_ADDR>
        <MEM_ADDR>0x43</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>PCIE2</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 2</DESCRIPTION>
          <TEXT>When the PCIE2 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt 2 is enabled. Any change on any enabled PCINT23..16 pin will cause an interrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI2 Interrupt Vector. PCINT23..16 pins are enabled individually by the PCMSK2 Register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCIE1</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 1</DESCRIPTION>
          <TEXT>When the PCIE1 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt 1 is enabled. Any change on any enabled PCINT10..8 pin will cause an interrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI1 Interrupt Vector. PCINT10..8 pins are enabled individually by the PCMSK1 Register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCIE0</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 0</DESCRIPTION>
          <TEXT>When the PCIE0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt 0 is enabled. Any change on any enabled PCINT7..0 pin will cause an interrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI0 Interrupt Vector. PCINT7..0 pins are enabled individually by the PCMSK0 Register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCICR>
    </EXTERNAL_INTERRUPT>
    <PORTB>
      <LIST>[PORTB:DDRB:PINB]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTB>
        <NAME>PORTB</NAME>
        <DESCRIPTION>Port B Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x05</IO_ADDR>
        <MEM_ADDR>0x25</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTB7</NAME>
          <DESCRIPTION>Port B Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTB6</NAME>
          <DESCRIPTION>Port B Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTB5</NAME>
          <DESCRIPTION>Port B Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTB4</NAME>
          <DESCRIPTION>Port B Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTB3</NAME>
          <DESCRIPTION>Port B Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTB2</NAME>
          <DESCRIPTION>Port B Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTB1</NAME>
          <DESCRIPTION>Port B Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTB0</NAME>
          <DESCRIPTION>Port B Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTB>
      <DDRB>
        <NAME>DDRB</NAME>
        <DESCRIPTION>Port B Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x04</IO_ADDR>
        <MEM_ADDR>0x24</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDB7</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDB6</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDB5</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDB4</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDB3</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDB2</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDB1</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDB0</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRB>
      <PINB>
        <NAME>PINB</NAME>
        <DESCRIPTION>Port B Input Pins</DESCRIPTION>
        <TEXT>The Port B Input Pins address - PINB - is not a register, and this address enables access to the physical value on each Port B pin. When reading PORTB, the Port B Data Latch is read, and when reading PINB, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>0x03</IO_ADDR>
        <MEM_ADDR>0x23</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINB7</NAME>
          <DESCRIPTION>Port B Input Pins bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINB6</NAME>
          <DESCRIPTION>Port B Input Pins bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINB5</NAME>
          <DESCRIPTION>Port B Input Pins bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINB4</NAME>
          <DESCRIPTION>Port B Input Pins bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINB3</NAME>
          <DESCRIPTION>Port B Input Pins bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINB2</NAME>
          <DESCRIPTION>Port B Input Pins bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINB1</NAME>
          <DESCRIPTION>Port B Input Pins bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINB0</NAME>
          <DESCRIPTION>Port B Input Pins bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINB>
    </PORTB>
    <PORTD>
      <LIST>[PORTD:DDRD:PIND]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTD>
        <NAME>PORTD</NAME>
        <DESCRIPTION>Port D Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x0B</IO_ADDR>
        <MEM_ADDR>0x2B</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTD7</NAME>
          <DESCRIPTION>Port D Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTD6</NAME>
          <DESCRIPTION>Port D Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTD5</NAME>
          <DESCRIPTION>Port D Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTD4</NAME>
          <DESCRIPTION>Port D Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTD3</NAME>
          <DESCRIPTION>Port D Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTD2</NAME>
          <DESCRIPTION>Port D Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTD1</NAME>
          <DESCRIPTION>Port D Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTD0</NAME>
          <DESCRIPTION>Port D Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTD>
      <DDRD>
        <NAME>DDRD</NAME>
        <DESCRIPTION>Port D Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x0A</IO_ADDR>
        <MEM_ADDR>0x2A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDD7</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDD6</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDD5</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDD4</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDD3</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDD2</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDD1</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDD0</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRD>
      <PIND>
        <NAME>PIND</NAME>
        <DESCRIPTION>Port D Input Pins</DESCRIPTION>
        <TEXT>The Port D Input Pins address - PIND - is not a register, and this address enables access to the physical value on each Port D pin. When reading PORTD, the Port D Data Latch is read, and when reading PIND, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>0x09</IO_ADDR>
        <MEM_ADDR>0x29</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PIND7</NAME>
          <DESCRIPTION>Port D Input Pins bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PIND6</NAME>
          <DESCRIPTION>Port D Input Pins bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PIND5</NAME>
          <DESCRIPTION>Port D Input Pins bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PIND4</NAME>
          <DESCRIPTION>Port D Input Pins bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PIND3</NAME>
          <DESCRIPTION>Port D Input Pins bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PIND2</NAME>
          <DESCRIPTION>Port D Input Pins bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PIND1</NAME>
          <DESCRIPTION>Port D Input Pins bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PIND0</NAME>
          <DESCRIPTION>Port D Input Pins bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PIND>
    </PORTD>
    <TIMER_COUNTER_1>
      <LIST>[T1CR:T10IFR]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID/>
      <TEXT>The Timer1 is an interval timer which can be used to generate periodical interrupts and as prescaler for Timer2, and Timer3. The Timer1 consists of a programmable 12-bit divider that input clock (CL1) can be driven by the Timer0 output clock (CLKT0), I/O clock (CLKI/O), Timer clock (CLT), the external input clock (T2I), the external input clock (T3I), and the 32 kHz crystal oscillator clock divided by 4 (SXC).</TEXT>
      <T1CR>
        <NAME>T1CR</NAME>
        <DESCRIPTION>Timer 1 Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x38</IO_ADDR>
        <MEM_ADDR>0x58</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>T1IE</NAME>
          <DESCRIPTION>Timer 1 Interrupt Enable Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT5>
          <NAME>T1CS2</NAME>
          <DESCRIPTION>Timer 1 Clock Select Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T1CS1</NAME>
          <DESCRIPTION>Timer 1 Clock Select Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T1CS0</NAME>
          <DESCRIPTION>Timer 1 Clock Select Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T1PS2</NAME>
          <DESCRIPTION>Timer 1 Prescaler Select Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T1PS1</NAME>
          <DESCRIPTION>Timer 1 Prescaler Select Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T1PS0</NAME>
          <DESCRIPTION>Timer 1 Prescaler Select Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T1CR>
      <T10IFR>
        <NAME>T10IFR</NAME>
        <DESCRIPTION>Timer1/0 Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x1A</IO_ADDR>
        <MEM_ADDR>0x3A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>T1F</NAME>
          <DESCRIPTION>Timer 1 Flag Bit</DESCRIPTION>
          <TEXT>When the interval timer in Timer1 generates an output clock pulse (CLKT1) the T1F bit is set (one). If the I-bit in SREG and the T1IE bit is set (one) at T1CR the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T0F</NAME>
          <DESCRIPTION>Timer 0 Flag Bit</DESCRIPTION>
          <TEXT>When the interval timer in Timer0 generates an output clock pulse (CLKT0) the T0F bit is set (one). If the I-bit in SREG and the T0IE bit is set (one) at T0CR the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T10IFR>
    </TIMER_COUNTER_1>
    <TIMER_COUNTER_2>
      <LIST>[T2CRA:T2CRB:T2MDR:T2ICRH:T2ICRL:T2CORH:T2CORL:T2IFR:T2IMR:T2MRA:T2MRB]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID/>
      <TEXT>Timer2 consist an 16-bit up counter stage with compare register (T2COR) and capture register (T2ICR). The timer can be used as event counter, as timer and as signal generator. The counter can be driven by internal and external clock sources.</TEXT>
      <T2CRA>
        <NAME>T2CRA</NAME>
        <DESCRIPTION>Timer 2 Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x11</IO_ADDR>
        <MEM_ADDR>0x31</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>T2E</NAME>
          <DESCRIPTION>Timer 2 Enable Bit</DESCRIPTION>
          <TEXT>This bit control the Timer2 block. The T2E bit must be written to logic one to enables Timer2, and if the T2E bit is written to logic zero, the Timer2 is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T2TS</NAME>
          <DESCRIPTION>Timer 2 Toggle with Start Bit</DESCRIPTION>
          <TEXT>The T2TS bit must be written to logic one if the modulator output of Timer2 is toggled when the timer is enabled with T2E, and if the T2TS bit is written to logic zero, the modulator output of Timer2 is not toggled with the timer enable.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T2ICS</NAME>
          <DESCRIPTION>Timer Input Capture Select Bit</DESCRIPTION>
          <TEXT>The T2ICS bit select the input capture signal of theTimer2, for more informations please refer the datasheet</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT3>
          <NAME>T2CRM</NAME>
          <DESCRIPTION>Timer 2 Compare Reset Mask Bit</DESCRIPTION>
          <TEXT>The T2CRM bit must be written to logic one for enable the counter reset if a match of the counter with the compare register occurs, and if the T2CRM bit is written to logic zero, the counter reset is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T2CR</NAME>
          <DESCRIPTION>Timer2 Counter Reset</DESCRIPTION>
          <TEXT>The T2CRA Bit resets the Counter2 asynchronously if this bit is set to a logic 1. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T2CTM</NAME>
          <DESCRIPTION>Timer 2 Compare Toggle Mask Bit</DESCRIPTION>
          <TEXT>The T2CTM bit must be written to logic one for enable the compare toggle, and if the T2CTM bit is written to logic zero, the compare toggle is disabled. A match of the counter with the compare register toggles the output flip-flop in the modulator of the Timer2 </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T2OTM</NAME>
          <DESCRIPTION>Timer 2 Overflow Toggle Mask Bit</DESCRIPTION>
          <TEXT>The T2OTM bit must be written to logic one for enable the overflow toggle, and if the T2OTM bit is written to logic zero, the overflow toggle is disabled. A counter overflow toggles the output flip-flop in the modulator of the Timer2 </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T2CRA>
      <T2CRB>
        <NAME>T2CRB</NAME>
        <DESCRIPTION>Timer 2 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x12</IO_ADDR>
        <MEM_ADDR>0x32</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT0>
          <NAME>T2SCE</NAME>
          <DESCRIPTION>Timer 2 Software Capture Enable Bit</DESCRIPTION>
          <TEXT>The T2SCE bit must be written to logic one to enable a software capture event. The T2SCE bit is cleared after the counter value is saved in the capture register. The Timer2 counter value is readable via its capture register during it is running</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T2CRB>
      <T2MDR>
        <NAME>T2MDR</NAME>
        <DESCRIPTION>Timer 2 Modulator Data Register</DESCRIPTION>
        <TEXT>The modulator Transmit Data Buffer Register and the modulator Receive Data Buffer Register shared the same I/O addressed referred to as modulator Data Register or T2MDR. The Transmit Data Buffer Register (TXB) will be the destination for data written to the T2MDR Register location. Reading the T2MDR Register location will return the contents of the Receive Data Buffer Register (RXB).</TEXT>
        <IO_ADDR>0x2F</IO_ADDR>
        <MEM_ADDR>0x4F</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>T2MDR7</NAME>
          <DESCRIPTION>Timer 2 Modulator Data Register Bit7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T2MDR6</NAME>
          <DESCRIPTION>Timer 2 Modulator Data Register Bit6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T2MDR5</NAME>
          <DESCRIPTION>Timer 2 Modulator Data Register Bit5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T2MDR4</NAME>
          <DESCRIPTION>Timer 2 Modulator Data Register Bit4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T2MDR3</NAME>
          <DESCRIPTION>Timer 2 Modulator Data Register Bit3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T2MDR2</NAME>
          <DESCRIPTION>Timer 2 Modulator Data Register Bit2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T2MDR1</NAME>
          <DESCRIPTION>Timer 2 Modulator Data Register Bit1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T2MDR0</NAME>
          <DESCRIPTION>Timer 2 Modulator Data Register Bit0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T2MDR>
      <T2ICRH>
        <NAME>T2ICR</NAME>
        <DESCRIPTION>Timer 2 Input Capture Register High Byte</DESCRIPTION>
        <TEXT>The Input Capture is updated with the counter value (T2CNT) each time an event occurs on the T2ICP pin (or optionally on Timer1 output clock CLKT1). The T2CNT content can be read via the capture register after a software capture event is enabled with the T2SCE bit.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6F</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>T2ICRH7</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register High Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T2ICRH6</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register High Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T2ICRH5</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register High Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T2ICRH4</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register High Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T2ICRH3</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register High Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T2ICRH2</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register High Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T2ICRH1</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register High Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T2ICRH0</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register High Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T2ICRH>
      <T2ICRL>
        <NAME>T2ICRL</NAME>
        <DESCRIPTION>Timer 2 Input Capture Register Low Byte</DESCRIPTION>
        <TEXT>The Input Capture is updated with the counter value (T2CNT) each time an event occurs on the T2ICP pin (or optionally on Timer1 output clock CLKT1). The T2CNT content can be read via the capture register after a software capture event is enabled with the T2SCE bit.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6E</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>T2ICRL7</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T2ICRL6</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T2ICRL5</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T2ICRL4</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T2ICRL3</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T2ICRL2</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T2ICRL1</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T2ICRL0</NAME>
          <DESCRIPTION>Timer 2 Input Capture Register Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T2ICRL>
      <T2CORH>
        <NAME>T2CORH</NAME>
        <DESCRIPTION>Timer2 Compare Register High Byte</DESCRIPTION>
        <TEXT>The Compare Registers contain a 16-bit value that is continuously compared with the counter value (T2CNT). A match can be used to generate an Compare interrupt, a counter reset , an output clock CLKT2 or to generate a waveform with the modulator on the output pins (T2O1, T2O2).</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x71</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>T2CORH7</NAME>
          <DESCRIPTION>Timer2 Compare Register High Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T2CORH6</NAME>
          <DESCRIPTION>Timer2 Compare Register High Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T2CORH5</NAME>
          <DESCRIPTION>Timer2 Compare Register High Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T2CORH4</NAME>
          <DESCRIPTION>Timer2 Compare Register High Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T2CORH3</NAME>
          <DESCRIPTION>Timer2 Compare Register High Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T2CORH2</NAME>
          <DESCRIPTION>Timer2 Compare Register High Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T2CORH1</NAME>
          <DESCRIPTION>Timer2 Compare Register High Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T2CORH0</NAME>
          <DESCRIPTION>Timer2 Compare Register High Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T2CORH>
      <T2CORL>
        <NAME>T2CORL</NAME>
        <DESCRIPTION>Timer2 Compare Register Low Byte</DESCRIPTION>
        <TEXT>The Compare Registers contain a 16-bit value that is continuously compared with the counter value (T2CNT). A match can be used to generate an Compare interrupt, a counter reset , an output clock CLKT2 or to generate a waveform with the modulator on the output pins (T2O1, T2O2).</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x70</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>T2CORL7</NAME>
          <DESCRIPTION>Timer2 Compare Register Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T2CORL6</NAME>
          <DESCRIPTION>Timer2 Compare Register Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T2CORL5</NAME>
          <DESCRIPTION>Timer2 Compare Register Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T2CORL4</NAME>
          <DESCRIPTION>Timer2 Compare Register Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T2CORL3</NAME>
          <DESCRIPTION>Timer2 Compare Register Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T2CORL2</NAME>
          <DESCRIPTION>Timer2 Compare Register Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T2CORL1</NAME>
          <DESCRIPTION>Timer2 Compare Register Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T2CORL0</NAME>
          <DESCRIPTION>Timer2 Compare Register Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T2CORL>
      <T2IFR>
        <NAME>T2IFR</NAME>
        <DESCRIPTION>Timer2 Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x1B</IO_ADDR>
        <MEM_ADDR>0x3B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>T2TCF</NAME>
          <DESCRIPTION>Timer2 SSI Transmit Complete Flag Bit</DESCRIPTION>
          <TEXT>This flag bit is set when the entire frame in the SSI Shift Register has been shifted out and there are no new data currently present in the transmit buffer (T2MDR). The T2TCF flag bit is automatically cleared when a transmit complete interrupt is executed, or it can be cleared by writing a one to its bit location. The T2TCF Flag can generate a Transmit Complete interrupt (see description of the T2TCIM bit).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T2TXF</NAME>
          <DESCRIPTION>Timer2 SSI Transmit Flag Bit</DESCRIPTION>
          <TEXT>The T2TXF flag indicates if the transmit buffer (T2MDR) is ready to receive new data. If T2TXF is one, the buffer is empty, and therefore ready to be written. The T2TXF Flag can generate a Data Register Empty interrupt (see description of the T2TXIM bit).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T2RXF</NAME>
          <DESCRIPTION>Timer2 SSI Receive Flag Bit</DESCRIPTION>
          <TEXT>This flag bit is set when there are unread data in the receive buffer and cleared when the receive buffer is empty (i.e., does not contain any unread data). If the Receiver is disabled, the receive buffer will be flushed and consequently the T2RXF bit will become zero. The T2RXF Flag can be used to generate a Receive Complete interrupt (see description of the T2RXIM bit).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T2ICF</NAME>
          <DESCRIPTION>Timer2 Input Capture Flag Bit</DESCRIPTION>
          <TEXT>This flag is set (one) and indicating that the Timer/Counter2 value has been transferred to the capture register (T2ICR) when a capture event on the T2ICP pin or an output clock of the Timer1 (CLKT1) occurs. T2ICF is automatically cleared when the interrupt acknowledge is executed. Alternatively, T2ICF can be cleared by writing a logic one to this bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T2COF</NAME>
          <DESCRIPTION>Timer 2 Compare Flag Bit</DESCRIPTION>
          <TEXT>This flag is set (one) in the timer clock cycle after the counter2 value matches with the compare register. The flag (T2COF) is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T2OFF</NAME>
          <DESCRIPTION>Timer 2 Overflow Flag Bit</DESCRIPTION>
          <TEXT>The setting (one) of this flag is dependent of the timer/counter overflow (OVF) or from the selected fixed TOP compare value. If the I-bit in SREG and the T2OIM bit is set (one) at T2IMR the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T2IFR>
      <T2IMR>
        <NAME>T2IMR</NAME>
        <DESCRIPTION>Timer 2 Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x74</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>T2TCIM</NAME>
          <DESCRIPTION>Timer2 SSI Transmit Complete Interrupt Mask Bit</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the T2TCF Flag. A Timer2 SSI transmit complete interrupt will be generated only if the T2TCIM bit is written to one, the Global Interrupt Flag in SREG is written to one and the T2TCF bit in T2IFR is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T2TXIM</NAME>
          <DESCRIPTION>Timer2 SSI Transmit Interrupt Mask Bit</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the T2TXF Flag. A Timer2 SSI transmit buffer empty interrupt will be generated only if the T2TXIM bit is written to one, the Global Interrupt Flag in SREG is written to one and the T2TXF bit in T2IFR is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T2RXIM</NAME>
          <DESCRIPTION>Timer2 SSI Receive Interrupt Mask Bit</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the T2RXF Flag. A Timer2 SSI receive buffer full interrupt will be generated only if the T2RXIM bit is written to one, the Global Interrupt Flag in SREG is written to one and the T2RXF bit in T2IFR is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T2CPIM</NAME>
          <DESCRIPTION>Timer 2 Capture Interrupt Mask Bit</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter2 Input Capture interrupt is enabled. The corresponding Interrupt Vector is executed when the T2ICF Flag, located in T2IFR, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T2CIM</NAME>
          <DESCRIPTION>Timer 2 Compare Interrupt Mask Bit</DESCRIPTION>
          <TEXT>When the T2CIM bit is written to one and the I-bit in the Status Register is set (one), the Timer/Counter2 Compare Match interrupt is enabled. The corresponding interrupt is executed if a compare match in Timer/Counter2 occurs, i.e., when the T2COF bit is set in the Timer/Counter2 Interrupt Flag Register - T2IFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T2OIM</NAME>
          <DESCRIPTION>Timer 2 Overflow Interrupt Mask Bit</DESCRIPTION>
          <TEXT>When the T2OIM bit is written to one and the I-bit in the Status Register is set (one), the Timer/Counter2 Overflow interrupt is enabled. The corresponding interrupt is executed if an overflow in Timer/Counter2 occurs, i.e., when the T2OFF bit is set in the Timer/Counter2 Interrupt Flag Register - T2IFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T2IMR>
      <T2MRA>
        <NAME>T2MRA</NAME>
        <DESCRIPTION>Timer 2 Mode Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x72</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>T2TP1</NAME>
          <DESCRIPTION>Timer 2 Top select Bit 1</DESCRIPTION>
          <TEXT>The T2TP1 and T2TP0 bits select the fixed TOP compare value of theTimer2, please refer to datasheet</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T2TP0</NAME>
          <DESCRIPTION>Timer 2 Top select Bit 0</DESCRIPTION>
          <TEXT>The T2TP1 and T2TP0 bits select the fixed TOP compare value of theTimer2</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T2CNC</NAME>
          <DESCRIPTION>Timer 2 Input Capture Noise Canceler Bit</DESCRIPTION>
          <TEXT>Setting this bit (to one) activates the Input Capture Noise Canceler. When the noise canceler is activated, the input from the Input Capture pin (T2ICP) or CLKT1 is filtered. The filter function requires four successive equal valued samples of the T2ICP pin for changing its output. The Input Capture is therefore delayed by four counter clock (CL2) cycles when the noise canceler is enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T2CE1</NAME>
          <DESCRIPTION>Timer 2 Capture Edge Select Bit 1</DESCRIPTION>
          <TEXT>The T2CE1 and T2CE0 bits select the edge from the capture input signal (T2ICP) of theTimer2, please refer to datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T2CE0</NAME>
          <DESCRIPTION>Timer 2 Capture Edge Select Bit 0</DESCRIPTION>
          <TEXT>The T2CE1 and T2CE0 bits select the edge from the capture input signal (T2ICP) of theTimer2, please refer to datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T2CS2</NAME>
          <DESCRIPTION>Timer 2 Clock Select Bit 2</DESCRIPTION>
          <TEXT>The T2CS2, T2CS1, and T2CS0 bits select the input clock (CL2) of theTimer2, for details please refer to datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T2CS1</NAME>
          <DESCRIPTION>Timer 2 Clock Select Bit 1</DESCRIPTION>
          <TEXT>The T2CS2, T2CS1, and T2CS0 bits select the input clock (CL2) of theTimer2, for details please refer to datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T2CS0</NAME>
          <DESCRIPTION>Timer 2 Clock Select Bit 0</DESCRIPTION>
          <TEXT>The T2CS2, T2CS1, and T2CS0 bits select the input clock (CL2) of theTimer2, for details please refer to datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T2MRA>
      <T2MRB>
        <NAME>T2MRB</NAME>
        <DESCRIPTION>Timer 2 Mode Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x73</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>T2SSIE</NAME>
          <DESCRIPTION>Timer 2 SSI Enable Bit</DESCRIPTION>
          <TEXT>This bit must be set to enable any SSI operation. When this bit is written to low, the SSI is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T2CPOL</NAME>
          <DESCRIPTION>Timer2 Clock Polarity for SSI shift clock</DESCRIPTION>
          <TEXT>When this bit is written to one, SCLK is high when idle. When T2CPOL is written to zero, SCLK is low when idle.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT4>
          <NAME>T2TOP</NAME>
          <DESCRIPTION>Timer 2 Toggle Output Preset Bit</DESCRIPTION>
          <TEXT>The T2TOP bit must be written to logic one for set the toggle flip-flop, and if the T2TOP bit is written to logic zero, resets the toggle flip-flop. This bit allows the programmer to preset the toggle output flip-flop in the modulator of the Timer2.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T2M3</NAME>
          <DESCRIPTION>Timer 2 Mode Bit 3</DESCRIPTION>
          <TEXT>The T2M3,T2M2,T2M1, and T2M0 bits select the modes of theTimer2 and additional the configuration of the modulator I/O-pins (T2O1, T2O2 &amp; SDIN)</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T2M2</NAME>
          <DESCRIPTION>Timer 2 Mode Bit 2</DESCRIPTION>
          <TEXT>The T2M3,T2M2,T2M1, and T2M0 bits select the modes of theTimer2 and additional the configuration of the modulator I/O-pins (T2O1, T2O2 &amp; SDIN)</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T2M1</NAME>
          <DESCRIPTION>Timer 2 Mode Bit 1</DESCRIPTION>
          <TEXT>The T2M3,T2M2,T2M1, and T2M0 bits select the modes of theTimer2 and additional the configuration of the modulator I/O-pins (T2O1, T2O2 &amp; SDIN)</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T2M0</NAME>
          <DESCRIPTION>Timer 2 Mode Bit 0</DESCRIPTION>
          <TEXT>The T2M3,T2M2,T2M1, and T2M0 bits select the modes of theTimer2 and additional the configuration of the modulator I/O-pins (T2O1, T2O2 &amp; SDIN)</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T2MRB>
    </TIMER_COUNTER_2>
    <TIMER_COUNTER_3>
      <LIST>[T3CRA:T3CRB:T3MRA:T3IFR:T3IMR:T3MRB:T3ICRH:T3ICRL:T3CORAH:T3CORAL:T3CORBH:T3CORBL]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID/>
      <TEXT>The 16-bit Timer/Counter unit allows accurate program execution timing (event management), wave generation, and signal timing measurement. The main features are: true 16-bit design; eight different clock sources selectable; one Output Compare Unit; two independent compare units; one input capture unit; input Capture Noise Canceler; clear Timer on Compare Match or Capture Event; variable PWM period; Frequency Generator; external Event Counter; four independent Interrupt Sources (T3CAP, T3COMA, T3COMB, T3OVF)</TEXT>
      <T3CRA>
        <NAME>T3CRA</NAME>
        <DESCRIPTION>Timer 3 Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x14</IO_ADDR>
        <MEM_ADDR>0x34</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>T3E</NAME>
          <DESCRIPTION>Timer 3 Enable Bit</DESCRIPTION>
          <TEXT>This bit control the Timer3 block. The T3E bit must be written to logic one to enables Timer3, and if the T3E bit is written to logic zero, the Timer3 is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T3TS</NAME>
          <DESCRIPTION>Timer 3 Toggle with Start Bit</DESCRIPTION>
          <TEXT>The T3TS bit must be written to logic one if the modulator output of Timer3 is toggled when the timer is enabled with T3E, and if the T3TS bit is written to logic zero, the modulator output of Timer3 is not toggled with the timer enable.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT2>
          <NAME>T3CR</NAME>
          <DESCRIPTION>Timer3 Counter Reset</DESCRIPTION>
          <TEXT>The T3CRA Bit resets the Counter3 asynchronously if this bit is set to a logic 1</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T3SCE</NAME>
          <DESCRIPTION>Timer 3 Software Capture Enable Bit</DESCRIPTION>
          <TEXT>The T3SCE bit must be written to logic one to enable a software capture event. The T3SCE bit is cleared after the counter value is saved in the capture register. The Timer3 counter value is readable via its capture register during it is running.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T3AC</NAME>
          <DESCRIPTION>Timer 3 Alternate Compare register sequence bit</DESCRIPTION>
          <TEXT>The T3AC bit must be written to logic one for enable the compare registers alternate mode, and if the T3AC bit is written to logic zero, the alternate mode is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T3CRA>
      <T3CRB>
        <NAME>T3CRB</NAME>
        <DESCRIPTION>Timer 3 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7E</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>T3CPRM</NAME>
          <DESCRIPTION>Timer 3 CaPture Reset Mask bit</DESCRIPTION>
          <TEXT>The T3CPRM bit must be written to logic one for enable the counter reset if an internal/external capture event occurs, and if the T3CRMB bit is written to logic zero, the counter reset is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T3CRMB</NAME>
          <DESCRIPTION>Timer 3 Compare Reset Mask bit B</DESCRIPTION>
          <TEXT>The T3CRMB bit must be written to logic one for enable the counter reset if a match of the counter with the compare register B (T3CORB) occurs, and if the T3CRMB bit is written to logic zero, the counter reset is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T3SAMB</NAME>
          <DESCRIPTION>Timer 3 Single Action Mask bit B</DESCRIPTION>
          <TEXT>The T3SAMB bit must be written to logic one for enable the single-compare mode, and if the T3SAMB bit is written to logic zero, the single-compare mode is disabled. After this bit is set, the compare register B (T3CORB) is used until the next compare match with the counter. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T3CTMB</NAME>
          <DESCRIPTION>Timer 3 Compare Toggle Mask bit B</DESCRIPTION>
          <TEXT>The T3CTMB bit must be written to logic one for enable the compare toggle, and if the T3CTMB bit is written to logic zero, the compare toggle is disabled. A match of the counter with the compare register B (T3CORB) toggles the output flip-flop in the modulator of the Timer3.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T3CRMA</NAME>
          <DESCRIPTION>Timer 3 Compare Reset Mask bit A</DESCRIPTION>
          <TEXT>The T3CRMA bit must be written to logic one for enable the counter reset if a match of the counter with the compare register A (T3CORA) occurs, and if the T3CRMA bit is written to logic zero, the counter reset is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T3SAMA</NAME>
          <DESCRIPTION>Timer 3 Single Action Mask bit A</DESCRIPTION>
          <TEXT>The T3SAMA bit must be written to logic one for enable the single-compare mode, and if the T3SAMA bit is written to logic zero, the single-compare mode is disabled. After this bit is set, the compare register A (T3CORA) is used until the next compare match with the counter.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T3CTMA</NAME>
          <DESCRIPTION>Timer 3 Compare Toggle Mask bit A</DESCRIPTION>
          <TEXT>The T3CTMA bit must be written to logic one for enable the compare toggle, and if the T3CTMA bit is written to logic zero, the compare toggle is disabled. A match of the counter with the compare register A (T3CORA) toggles the output flip-flop in the modulator of the Timer3.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T3CRB>
      <T3MRA>
        <NAME>T3MRA</NAME>
        <DESCRIPTION>Timer 3 Mode Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7C</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>T3ICS1</NAME>
          <DESCRIPTION>Timer 3 Input Capture Select Bit 1</DESCRIPTION>
          <TEXT>The T3ICS1 and T3ICS0 bits select the input capture signal of theTimer3, for more details please see datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T3ICS0</NAME>
          <DESCRIPTION>Timer 3 Input Capture Select Bit 0</DESCRIPTION>
          <TEXT>The T3ICS1 and T3ICS0 bits select the input capture signal of theTimer3, for more details please see datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T3CNC</NAME>
          <DESCRIPTION>Timer 3 input Capture Noise Canceler Bit</DESCRIPTION>
          <TEXT>Setting this bit (to one) activates the Input Capture Noise Canceler. When the noise canceler is activated, the input from the Input Capture pin is filtered. The filter function requires four successive equal valued samples of the Input Capture pin for changing its output. The Input Capture is therefore delayed by four counter clock (CL3) cycles when the noise canceler is enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T3CE1</NAME>
          <DESCRIPTION>Timer 3 Capture Edge select Bit 1</DESCRIPTION>
          <TEXT>The T3CE1 and T3CE0 bits select the edge from all input signal of theTimer3, for more details please see datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T3CE0</NAME>
          <DESCRIPTION>Timer 3 Capture Edge select Bit 0</DESCRIPTION>
          <TEXT>The T3CE1 and T3CE0 bits select the edge from all input signal of theTimer3, for more details please see datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T3CS2</NAME>
          <DESCRIPTION>Timer 3 Clock Select Bit 2</DESCRIPTION>
          <TEXT>The T3CS2, T3CS1, and T3CS0 bits select the input clock (CL3) of theTimer3, for more details please see datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T3CS1</NAME>
          <DESCRIPTION>Timer 3 Clock Select Bit 1</DESCRIPTION>
          <TEXT>The T3CS2, T3CS1, and T3CS0 bits select the input clock (CL3) of theTimer3, for more details please see datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T3CS0</NAME>
          <DESCRIPTION>Timer 3 Clock Select Bit 0</DESCRIPTION>
          <TEXT>The T3CS2, T3CS1, and T3CS0 bits select the input clock (CL3) of theTimer3, for more details please see datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T3MRA>
      <T3IFR>
        <NAME>T3IFR</NAME>
        <DESCRIPTION>Timer3 Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x1C</IO_ADDR>
        <MEM_ADDR>0x3C</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>T3ICF</NAME>
          <DESCRIPTION>Timer3 Input Capture Flag bit</DESCRIPTION>
          <TEXT>This flag is set (one) when a capture event occurs on the T3ICP pin and indicating that the Timer/Counter3 value has been transferred to the capture register (T3ICR). If the I-bit in SREG and the T3CPIM bit is set (one) at T3IMR register, the MCU will jump to the corresponding Interrupt Vector.T3ICF is automatically cleared when the interrupt acknowledge is executed. Alternatively, T3ICP can be cleared by writing a logic one to this bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T3COBF</NAME>
          <DESCRIPTION>Timer3 Compare B Flag bit</DESCRIPTION>
          <TEXT>This flag is set (one) in the timer clock cycle after the counter3 value matches with the compare register B. If the I-bit in SREG and the T3CBIM bit is set (one) at T3IMR register, the MCU will jump to the corresponding Interrupt Vector. The flag (T3COBF) is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T3COAF</NAME>
          <DESCRIPTION>Timer3 Compare A Flag bit</DESCRIPTION>
          <TEXT>This flag is set (one) in the timer clock cycle after the counter3 value matches with the compare register A. If the I-bit in SREG and the T3CAIM bit is set (one) at T3IMR register, the MCU will jump to the corresponding Interrupt Vector. The flag (T3COAF) is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T3OFF</NAME>
          <DESCRIPTION>Timer3 OverFlow Flag bit</DESCRIPTION>
          <TEXT>The setting (one) of this flag is dependent of the timer/counter3 overflow (OVF), if the T3FTM bit is set (one). If the I-bit in SREG and the T3OIM bit is set (one) at T3IMR register, the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T3IFR>
      <T3IMR>
        <NAME>T3IMR</NAME>
        <DESCRIPTION>Timer3 Interrupt Mask Register </DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7F</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>T3CPIM</NAME>
          <DESCRIPTION>Timer3 Capture Interrupt Mask bit</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter3 Input Capture interrupt is enabled. The corresponding Interrupt Vector  is executed when the T3ICF Flag, located in T3IFR, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T3CBIM</NAME>
          <DESCRIPTION>Timer3 Compare B Interrupt Mask bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T3CAIM</NAME>
          <DESCRIPTION>Timer3 Compare A Interrupt Mask bit</DESCRIPTION>
          <TEXT>When the T3CAIM bit is written to one and the I-bit in the Status Register is set (one), the Timer/Counter3 Compare Match A interrupt is enabled. The corresponding interrupt is executed if a compare match in Timer/Counter3 occurs, i.e., when the T3COAF bit is set in the Timer/Counter3 Interrupt Flag Register - T3IFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T3OIM</NAME>
          <DESCRIPTION>Timer3 Overflow Interrupt Mask bit</DESCRIPTION>
          <TEXT>When the T3OIM bit is written to one and the I-bit in the Status Register is set (one), the Timer/Counter3 Overflow interrupt is enabled. The corresponding interrupt is executed if an overflow in Timer/Counter3 occurs, i.e., when the T3OFF bit is set in the Timer/Counter3 Interrupt Flag Register - T3IFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T3IMR>
      <T3MRB>
        <NAME>T3MRB</NAME>
        <DESCRIPTION>Timer 3 Mode Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7D</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT4>
          <NAME>T3TOP</NAME>
          <DESCRIPTION>Timer 3 Toggle Output Preset Bit</DESCRIPTION>
          <TEXT>The T3TOP bit must be written to logic one for set the toggle flip-flop, and if the T3TOP bit is written to logic zero, resets the toggle flip-flop. This bit allows the programmer to preset the toggle output flip-flop in the modulator of the Timer3.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT2>
          <NAME>T3M2</NAME>
          <DESCRIPTION>Timer 3 Mode Bit 2</DESCRIPTION>
          <TEXT>The T3M2,T3M1, and T3M0 bits select the output mode of theTimer3</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T3M1</NAME>
          <DESCRIPTION>Timer 3 Mode Bit 1</DESCRIPTION>
          <TEXT>The T3M2,T3M1, and T3M0 bits select the output mode of theTimer3</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T3M0</NAME>
          <DESCRIPTION>Timer 3 Mode Bit 0</DESCRIPTION>
          <TEXT>The T3M2,T3M1, and T3M0 bits select the output mode of theTimer3</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T3MRB>
      <T3ICRH>
        <NAME>T3ICRH</NAME>
        <DESCRIPTION>Timer3 Input Capture Register High Byte</DESCRIPTION>
        <TEXT>The Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x77</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>T3ICRH7</NAME>
          <DESCRIPTION>Timer3 Input Capture Register High Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T3ICRH6</NAME>
          <DESCRIPTION>Timer3 Input Capture Register High Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T3ICRH5</NAME>
          <DESCRIPTION>Timer3 Input Capture Register High Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T3ICRH4</NAME>
          <DESCRIPTION>Timer3 Input Capture Register High Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T3ICRH3</NAME>
          <DESCRIPTION>Timer3 Input Capture Register High Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T3ICRH2</NAME>
          <DESCRIPTION>Timer3 Input Capture Register High Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T3ICRH1</NAME>
          <DESCRIPTION>Timer3 Input Capture Register High Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T3ICRH0</NAME>
          <DESCRIPTION>Timer3 Input Capture Register High Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T3ICRH>
      <T3ICRL>
        <NAME>T3ICRL</NAME>
        <DESCRIPTION>Timer3 Input Capture Register Low Byte</DESCRIPTION>
        <TEXT>The Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x76</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>T3ICRL7</NAME>
          <DESCRIPTION>Timer3 Input Capture Register Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T3ICRL6</NAME>
          <DESCRIPTION>Timer3 Input Capture Register Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T3ICRL5</NAME>
          <DESCRIPTION>Timer3 Input Capture Register Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T3ICRL4</NAME>
          <DESCRIPTION>Timer3 Input Capture Register Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T3ICRL3</NAME>
          <DESCRIPTION>Timer3 Input Capture Register Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T3ICRL2</NAME>
          <DESCRIPTION>Timer3 Input Capture Register Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T3ICRL1</NAME>
          <DESCRIPTION>Timer3 Input Capture Register Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T3ICRL0</NAME>
          <DESCRIPTION>Timer3 Input Capture Register Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T3ICRL>
      <T3CORAH>
        <NAME>T3CORAH</NAME>
        <DESCRIPTION>Timer3 COmpare Register A High Byte</DESCRIPTION>
        <TEXT>The Compare Registers contain a 16-bit value that is continuously compared with the counter value (T3CNT). A match can be used to generate an Compare interrupt, a counter reset , an output clock CLKT3 or to generate a waveform with the modulator on the external output pin (T3O).</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x79</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>T3CORAH7</NAME>
          <DESCRIPTION>Timer3 COmpare Register A High Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T3CORAH6</NAME>
          <DESCRIPTION>Timer3 COmpare Register A High Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T3CORAH5</NAME>
          <DESCRIPTION>Timer3 COmpare Register A High Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T3CORAH4</NAME>
          <DESCRIPTION>Timer3 COmpare Register A High Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T3CORAH3</NAME>
          <DESCRIPTION>Timer3 COmpare Register A High Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T3CORAH2</NAME>
          <DESCRIPTION>Timer3 COmpare Register A High Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T3CORAH1</NAME>
          <DESCRIPTION>Timer3 COmpare Register A High Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T3CORAH0</NAME>
          <DESCRIPTION>Timer3 COmpare Register A High Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T3CORAH>
      <T3CORAL>
        <NAME>T3CORAL</NAME>
        <DESCRIPTION>Timer3 COmpare Register A Low Byte</DESCRIPTION>
        <TEXT>The Compare Registers contain a 16-bit value that is continuously compared with the counter value (T3CNT). A match can be used to generate an Compare interrupt, a counter reset , an output clock CLKT3 or to generate a waveform with the modulator on the external output pin (T3O).</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x78</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>T3CORAL7</NAME>
          <DESCRIPTION>Timer3 COmpare Register A Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T3CORAL6</NAME>
          <DESCRIPTION>Timer3 COmpare Register A Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T3CORAL5</NAME>
          <DESCRIPTION>Timer3 COmpare Register A Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T3CORAL4</NAME>
          <DESCRIPTION>Timer3 COmpare Register A Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T3CORAL3</NAME>
          <DESCRIPTION>Timer3 COmpare Register A Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T3CORAL2</NAME>
          <DESCRIPTION>Timer3 COmpare Register A Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T3CORAL1</NAME>
          <DESCRIPTION>Timer3 COmpare Register A Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T3CORAL0</NAME>
          <DESCRIPTION>Timer3 COmpare Register A Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T3CORAL>
      <T3CORBH>
        <NAME>T3CORBH</NAME>
        <DESCRIPTION>Timer3 COmpare Register B High Byte</DESCRIPTION>
        <TEXT>The Compare Registers contain a 16-bit value that is continuously compared with the counter value (T3CNT). A match can be used to generate an Compare interrupt, a counter reset , an output clock CLKT3 or to generate a waveform with the modulator on the external output pin (T3O).</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7B</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>T3CORBH7</NAME>
          <DESCRIPTION>Timer3 COmpare Register B High Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T3CORBH6</NAME>
          <DESCRIPTION>Timer3 COmpare Register B High Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T3CORBH5</NAME>
          <DESCRIPTION>Timer3 COmpare Register B High Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T3CORBH4</NAME>
          <DESCRIPTION>Timer3 COmpare Register B High Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T3CORBH3</NAME>
          <DESCRIPTION>Timer3 COmpare Register B High Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T3CORBH2</NAME>
          <DESCRIPTION>Timer3 COmpare Register B High Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T3CORBH1</NAME>
          <DESCRIPTION>Timer3 COmpare Register B High Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T3CORBH0</NAME>
          <DESCRIPTION>Timer3 COmpare Register B High Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T3CORBH>
      <T3CORBL>
        <NAME>T3CORBL</NAME>
        <DESCRIPTION>Timer3 COmpare Register B Low Byte</DESCRIPTION>
        <TEXT>The Compare Registers contain a 16-bit value that is continuously compared with the counter value (T3CNT). A match can be used to generate an Compare interrupt, a counter reset , an output clock CLKT3 or to generate a waveform with the modulator on the external output pin (T3O).</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7A</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>T3CORBL7</NAME>
          <DESCRIPTION>Timer3 COmpare Register B Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T3CORBL6</NAME>
          <DESCRIPTION>Timer3 COmpare Register B Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T3CORBL5</NAME>
          <DESCRIPTION>Timer3 COmpare Register B Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T3CORBL4</NAME>
          <DESCRIPTION>Timer3 COmpare Register B Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T3CORBL3</NAME>
          <DESCRIPTION>Timer3 COmpare Register B Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T3CORBL2</NAME>
          <DESCRIPTION>Timer3 COmpare Register B Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T3CORBL1</NAME>
          <DESCRIPTION>Timer3 COmpare Register B Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T3CORBL0</NAME>
          <DESCRIPTION>Timer3 COmpare Register B Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T3CORBL>
    </TIMER_COUNTER_3>
    <WATCHDOG>
      <LIST>[WDTCR]</LIST>
      <LINK/>
      <ICON>io_watch.bmp</ICON>
      <ID/>
      <TEXT/>
      <WDTCR>
        <NAME>WDTCR</NAME>
        <DESCRIPTION>Watchdog Timer Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x60</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT4>
          <NAME>WDCE</NAME>
          <DESCRIPTION>Watchdog Change Enable</DESCRIPTION>
          <TEXT>This bit must be set when the WDE bit is written to logic zero.Otherwise,the watchdog will not be disabled.Once written to one,hardware will clear this bit after four clock cycles.Refer to the description of the WDE bit for a watchdog disable procedure.This bit must also be set when changing the prescaler bits.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WDE</NAME>
          <DESCRIPTION>Watch Dog Enable</DESCRIPTION>
          <TEXT>When the WDE is set (one) the Watchdog Timer is enabled, and if the WDE is cleared (zero) the Watchdog Timer function is disabled. WDE can only be cleared if the WDCE bit is set(one). To disable an enabled watchdog timer, the following procedure must be followed: 1. In the same operation, write a logical one to WDCE and WDE. A logical one must be written to WDE even though it is set to one before the disable operation starts. 2. Within the next four clock cycles, write a logical 0 to WDE. This disables the watchdo</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>WDPS2</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler Select bit 2</DESCRIPTION>
          <TEXT>The WDPS2,WDPS1,and WDPS0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>WDPS1</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler Select bit 1</DESCRIPTION>
          <TEXT>The WDPS2,WDPS1,and WDPS0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WDPS0</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler Select bit 0</DESCRIPTION>
          <TEXT>The WDPS2,WDPS1,and WDPS0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </WDTCR>
    </WATCHDOG>
    <TIMER_COUNTER_0>
      <LIST>[T0CR:T10IFR]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID/>
      <TEXT>The Timer 0 consists of a programmable 20-stage divider that is driven by SCL. The timer output signal (CLKT0) can be used as prescaler clock and as source for the Timer 0 interrupt. The interrupt is maskable via the T0IE bit and also the time interval for the timer output can be adjusted via the T0PS[2..0] bits in the Timer 0 control register T0CR.</TEXT>
      <T0CR>
        <NAME>T0CR</NAME>
        <DESCRIPTION>Timer 0 Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x39</IO_ADDR>
        <MEM_ADDR>0x59</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>T0PBS2</NAME>
          <DESCRIPTION>Timer 0 Prescaler B Select Bit 2</DESCRIPTION>
          <TEXT>The T0PBS2, T0PBS1, and T0PBS0 bits determine the Timer 0 prescaling clock output (CLKSEN) and additionally the mode of the motion sensor.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T0PBS1</NAME>
          <DESCRIPTION>Timer 0 Prescaler B Select Bit 1</DESCRIPTION>
          <TEXT>The T0PBS2, T0PBS1, and T0PBS0 bits determine the Timer 0 prescaling clock output (CLKSEN) and additionally the mode of the motion sensor.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>T0PBS0</NAME>
          <DESCRIPTION>Timer 0 Prescaler B Select Bit 0</DESCRIPTION>
          <TEXT>The T0PBS2, T0PBS1, and T0PBS0 bits determine the Timer 0 prescaling clock output (CLKSEN) and additionally the mode of the motion sensor.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>T0PR</NAME>
          <DESCRIPTION>Timer 0 Prescaler Reset Bit</DESCRIPTION>
          <TEXT>Writing T0PR to one restarts the watchdog prescaler. Once written to one, hardware will clear this bit after four clock cycles. Only if the watchdog function is disabled the watchdog prescaler can be restarted.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>T0IE</NAME>
          <DESCRIPTION>Timer 0 Interrupt Enable Bit</DESCRIPTION>
          <TEXT>Writing T0IE to one enables a interval timer interrupt if the I bit in SREG is set. Writing T0IE to zero disables the interrupt. The corresponding Interrupt Vector is executed when the T0F Flag, located in T10FR, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>T0PAS2</NAME>
          <DESCRIPTION>Timer 0 Prescaler A Select Bit 2</DESCRIPTION>
          <TEXT>The T0PAS2, T0PSA1, and T0PAS0 bits determine the Timer 0 prescaling clock output (CLKT0).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>T0PAS1</NAME>
          <DESCRIPTION>Timer 0 Prescaler A Select Bit 1</DESCRIPTION>
          <TEXT>The T0PAS2, T0PSA1, and T0PAS0 bits determine the Timer 0 prescaling clock output (CLKT0).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T0PAS0</NAME>
          <DESCRIPTION>Timer 0 Prescaler A Select Bit 0</DESCRIPTION>
          <TEXT>The T0PAS2, T0PSA1, and T0PAS0 bits determine the Timer 0 prescaling clock output (CLKT0).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T0CR>
      <T10IFR>
        <NAME>T10IFR</NAME>
        <DESCRIPTION>Timer1/0 Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x1A</IO_ADDR>
        <MEM_ADDR>0x3A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>T1F</NAME>
          <DESCRIPTION>Timer 1 Flag Bit</DESCRIPTION>
          <TEXT>When the interval timer in Timer1 generates an output clock pulse (CLKT1) the T1F bit is set (one). If the I-bit in SREG and the T1IE bit is set (one) at T1CR the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>T0F</NAME>
          <DESCRIPTION>Timer 0 Flag Bit</DESCRIPTION>
          <TEXT>When the interval timer in Timer0 generates an output clock pulse (CLKT0) the T0F bit is set (one). If the I-bit in SREG and the T0IE bit is set (one) at T0CR the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </T10IFR>
    </TIMER_COUNTER_0>
    <EEPROM>
      <LIST>[EEARL:EEARH:EEDR:EECR]</LIST>
      <LINK/>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT>EEPROM Read/Write Access. The EEPROM access registers are accessible in the I/O space. The write access time for the EEPROM is given in Table 1. A self-timing function, however, lets the user software detect when the next byte can be written. If the user code contains instructions that write the EEPROM, some precautions must be taken. In heavily filtered power supplies, V CC is likely to rise or fall slowly on power-up/down. This causes the device for some period of time to run at a voltage lower than specified as minimum for the clock frequency used. See &#x201C;Preventing EEPROM Corruption&#x201D; on page 19. for details on how to avoid problems in these situations.In order to prevent unintentional EEPROM writes, a specific write procedure must be followed. Refer to the description of the EEPROM Control Register for details on this. When the EEPROM is read, the CPU is halted for four clock cycles before the next instruction is executed. When theEEPROM is written, the CPU is halted for two clock cycles before the next instruction is execut</TEXT>
      <EEARH>
        <NAME>EEARH</NAME>
        <DESCRIPTION>EEPROM Address Register High Byte</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x22</IO_ADDR>
        <MEM_ADDR>0x42</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT0>
          <NAME>EEAR8</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEARH>
      <EEARL>
        <NAME>EEARL</NAME>
        <DESCRIPTION>EEPROM Address Register Low Byte</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x21</IO_ADDR>
        <MEM_ADDR>0x41</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>EEAR7</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>EEAR6</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEAR5</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEAR4</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEAR3</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEAR2</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEAR1</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEAR0</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEARL>
      <EEDR>
        <NAME>EEDR</NAME>
        <DESCRIPTION>EEPROM Data Register</DESCRIPTION>
        <TEXT>For the EEPROM write operation, the EEDR register contains the data to be written to the EEPROM in the address given by the EEAR register. For the EEPROM read operation, the EEDR contains the data read out from the EEPROM at the address given by EEAR.</TEXT>
        <IO_ADDR>0x20</IO_ADDR>
        <MEM_ADDR>0x40</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>EEDR7</NAME>
          <DESCRIPTION>EEPROM Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>EEDR6</NAME>
          <DESCRIPTION>EEPROM Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEDR5</NAME>
          <DESCRIPTION>EEPROM Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEDR4</NAME>
          <DESCRIPTION>EEPROM Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEDR3</NAME>
          <DESCRIPTION>EEPROM Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEDR2</NAME>
          <DESCRIPTION>EEPROM Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEDR1</NAME>
          <DESCRIPTION>EEPROM Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEDR0</NAME>
          <DESCRIPTION>EEPROM Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEDR>
      <EECR>
        <NAME>EECR</NAME>
        <DESCRIPTION>EEPROM Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x1F</IO_ADDR>
        <MEM_ADDR>0x3F</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>EEPM1</NAME>
          <DESCRIPTION>EEPROM Programming Mode Bit 1</DESCRIPTION>
          <TEXT>The EEPROM Programming mode bit setting defines which programming action that will be triggered when writing EEPE. It is possible to program data in one atomic operation (erase the old value and program the new value) or to split the Erase and Write operations in two different operations. The Programming times for the different modes are shown in Table 2. While EEPE is set, any write to EEPMn will be ignored. During reset, the EEPMn bits will be reset to 0b00 unless the EEPROM is busy programming.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEPM0</NAME>
          <DESCRIPTION>EEPROM Programming Mode Bit 0</DESCRIPTION>
          <TEXT>The EEPROM Programming mode bit setting defines which programming action that will be triggered when writing EEPE. It is possible to program data in one atomic operation (erase the old value and program the new value) or to split the Erase and Write operations in two different operations. The Programming times for the different modes are shown in Table 2. While EEPE is set, any write to EEPMn will be ignored. During reset, the EEPMn bits will be reset to 0b00 unless the EEPROM is busy programming.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EERIE</NAME>
          <DESCRIPTION>EEPROM Ready Interrupt Enable</DESCRIPTION>
          <TEXT>EEPROM Ready Interrupt Enable Writing EERIE to one enables the EEPROM Ready Interrupt if the I bit in SREG is set. Writing EERIE to zero disables the interrupt. The EEPROM Ready interrupt generates a constant interrupt when EEWE is cleared.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEMWE</NAME>
          <DESCRIPTION>EEPROM Master Write Enable</DESCRIPTION>
          <TEXT>The EEMWE bit determines whether setting EEWE to one causes the EEPROM to be written. When EEMWE is written to one, writing EEWE to one within 4 clock cycles will write data to the EEPROM at the selected address. If EEMWE is zero, writing EEWE to one will have no effect. When EEMWE has been written to one by software, hardware clears the bit to zero after four clock cycles. See the description of the EEWE bit for an EEPROM write procedure.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEWE</NAME>
          <DESCRIPTION>EEPROM Write Enable</DESCRIPTION>
          <TEXT>The EEPROM Write Enable Signal EEWE is the write strobe to the EEPROM. When address and data are correctly set up, the EEWE bit must be set to write the value into the EEPROM. The EEMWE bit must be set when the logical one is written to EEWE, otherwise no EEPROM write takes place. The following procedure should be followed when writing the EEPROM (the order of steps 3 and 4 is not essential): 1. Wait until EEWE becomes zero. 2. Wait until SPMEN in SPMCR becomes zero. 3. Write new EEPROM address to EEAR (optional). 4. Write new EEPROM data to EEDR (optional). 5. Write a logical one to the EEMWE bit while writing a zero to EEWE in EECR. 6. Within four clock cycles after setting EEMWE, write a logical one to EEWE. The EEPROM can not be programmed during a CPU write to the Flash memory. The software must check that the Flash programming is completed before initiating a new EEPROM write. Step 2 is only relevant if the software contains a boot loader allowing the CPU to program the Flash. If the Flash is never being updated by the CPU, step 2 can be omitted. See &#x201C;Boot Loader Support - Read While Write self-programming&#x201D; on page 228 for details about boot programming. Caution: An interrupt between step 5 and step 6 will make the write cycle fail, since the EEPROM Master Write Enable will time-out. If an interrupt routine accessing the EEPROM is interrupting another EEPROM access, the EEAR or EEDR regis-ter will be modified, causing the interrupted EEPROM access to fail. It is recommended to have the global interrupt flag cleared during the 4 last steps to avoid these problems. When the write access time has elapsed, the EEWE bit is cleared by hardware. The user software can poll this bit and wait for a zero before writing the next byte. When EEWE has been set, the CPU is halted for two cycles before the next instruc-tion is executed</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EERE</NAME>
          <DESCRIPTION>EEPROM Read Enable</DESCRIPTION>
          <TEXT>The EEPROM Read Enable Signal EERE is the read strobe to the EEPROM. When the correct address is set up in the EEAR register, the EERE bit must be written to a logic one to trigger the EEPROM read. The EEPROM read access takes one instruction, and the requested data is available immediately. When the EEPROM is read, the CPU is halted for four cycles before the next instruction is executed. The user should poll the EEWE bit before starting the read operation. If a write operation is in progress, it is neither possible to read the EEPROM, nor to change the EEAR register. The calibrated oscillator is used to time the EEPROM accesses. Table 1 lists the typical programming time for EEPROM access from the CPU</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EECR>
    </EEPROM>
    <PORTC>
      <LIST>[PORTC:DDRC:PINC]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTC>
        <NAME>PORTC</NAME>
        <DESCRIPTION>Port C Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x08</IO_ADDR>
        <MEM_ADDR>0x28</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT2>
          <NAME>PORTC2</NAME>
          <DESCRIPTION>Port C Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTC1</NAME>
          <DESCRIPTION>Port C Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTC0</NAME>
          <DESCRIPTION>Port C Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTC>
      <DDRC>
        <NAME>DDRC</NAME>
        <DESCRIPTION>Port C Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x07</IO_ADDR>
        <MEM_ADDR>0x27</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT2>
          <NAME>DDC2</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDC1</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDC0</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRC>
      <PINC>
        <NAME>PINC</NAME>
        <DESCRIPTION>Port C Input Pins</DESCRIPTION>
        <TEXT>The Port C Input Pins address - PINC - is not a register, and this address enables access to the physical value on each Port C pin. When reading PORTC, the Port C Data Latch is read, and when reading PINC, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>0x06</IO_ADDR>
        <MEM_ADDR>0x26</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT2>
          <NAME>PINC2</NAME>
          <DESCRIPTION>Port C Input Pins bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINC1</NAME>
          <DESCRIPTION>Port C Input Pins bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINC0</NAME>
          <DESCRIPTION>Port C Input Pins bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINC>
    </PORTC>
  </IO_MODULE>
  <ICE_SETTINGS>
    <MODULE_LIST>[JTAGICEmkII:STK500:STK500_2:STK500_2:AVRDragon:AVRISPmkII]</MODULE_LIST>
    <JTAGICEmkII>
      <ID>0x9382</ID>
      <Interface>DebugWire</Interface>
<!--Bit 0 in byte 0 is I/O location, bit 7 in byte 7 is I/O location 63-->
      <ucRead>0xF8,0x8F,0xD7,0xFF,0x9F,0xFF,0xFD,0xFB</ucRead>
      <ucWrite>0xB0,0x8D,0xD7,0xFF,0x9F,0xFF,0xB8,0xFB</ucWrite>
      <ucReadShadow>0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00</ucReadShadow>
      <ucWriteShadow>0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00</ucWriteShadow>
<!--Bit 0 in byte 0 is extended I/O location, bit 7 in byte 7 is I/O location 63-->
      <ucExtRead>0xF3,0xDF,0xDF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtRead>
      <ucExtWrite>0xF3,0x1F,0x1F,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtWrite>
      <ucExtReadShadow>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtReadShadow>
      <ucExtWriteShadow>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtWriteShadow>
<!--Register locations etc.-->
      <ucIDRAddress>0x00</ucIDRAddress>
      <ucSPMCAddress>0X00</ucSPMCAddress>
      <ucRAMPZAddress>0X00</ucRAMPZAddress>
      <ulFlashPageSize>64</ulFlashPageSize>
      <ulEepromPageSize>4</ulEepromPageSize>
      <ulBootAddress>0x0F80</ulBootAddress>
      <BootAddress11>0x0F80</BootAddress11>
      <BootAddress10>0x0F00</BootAddress10>
      <BootAddress01>0x0E00</BootAddress01>
      <BootAddress00>0x0C00</BootAddress00>
      <ucUpperExtIOLoc>0x85</ucUpperExtIOLoc>
      <ulFlashSize>0x2000</ulFlashSize>
      <ulRegStart>0x0000,32</ulRegStart>
      <ulIoStart>0x0020,64</ulIoStart>
<!--Other stuff-->
      <DWENmaskExt>0x00</DWENmaskExt>
      <DWENmaskHigh>0x40</DWENmaskHigh>
      <DWENmaskLow>0x00</DWENmaskLow>
      <SPIENmaskExt>0x00</SPIENmaskExt>
      <SPIENmaskHigh>0x20</SPIENmaskHigh>
      <SPIENmaskLow>0x00</SPIENmaskLow>
      <ucEepromInst>0xBD,0xF2,0xBD,0xE1,0xBB,0xCF,0xB4,0x00,0xBE,0x01,0xB6,0x01,0xBC,0x00,0xBB,0xBF,0x99,0xF9,0xBB,0xAF</ucEepromInst>
      <ucFlashInst>0xB6,0x01,0x11</ucFlashInst>
      <ucSPHaddr>0x3e</ucSPHaddr>
      <ucSPLaddr>0x3d</ucSPLaddr>
      <DWdatareg>0x31</DWdatareg>
      <DWbasePC>0x10</DWbasePC>
      <Osccalshared>0x00</Osccalshared>
      <ucAllowFullPageBitstream>0x00</ucAllowFullPageBitstream>
      <uiStartSmallestBootLoaderSection>0xF80</uiStartSmallestBootLoaderSection>
      <ucUseJTAGID>0x00</ucUseJTAGID>
      <EECRAddress>0x3f</EECRAddress>
    </JTAGICEmkII>
    <STK500>
      <DeviceId>0x73</DeviceId>
      <SelfTimed>1</SelfTimed>
      <FullParallel>1</FullParallel>
      <Polled>1</Polled>
      <FPoll>0xFF</FPoll>
      <EPol1>0xFF</EPol1>
      <EPol2>0xFF</EPol2>
      <ComLockFuseRead>0</ComLockFuseRead>
      <ResetDisable>1</ResetDisable>
    </STK500>
    <STK500_2>
      <IspEnterProgMode>
        <timeout>200</timeout>
        <stabDelay>100</stabDelay>
        <cmdexeDelay>25</cmdexeDelay>
        <synchLoops>32</synchLoops>
        <byteDelay>0</byteDelay>
        <pollIndex>3</pollIndex>
        <pollValue>0x53</pollValue>
      </IspEnterProgMode>
      <IspLeaveProgMode>
        <preDelay>1</preDelay>
        <postDelay>1</postDelay>
      </IspLeaveProgMode>
      <IspChipErase>
        <eraseDelay>45</eraseDelay>
        <pollMethod>1</pollMethod>
      </IspChipErase>
      <IspProgramFlash>
        <mode>0x41</mode>
        <blockSize>64</blockSize>
        <delay>6</delay>
        <cmd1>0x40</cmd1>
        <cmd2>0x4C</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramFlash>
      <IspProgramEeprom>
        <mode>0x41</mode>
        <blockSize>4</blockSize>
        <delay>5</delay>
        <cmd1>0xC1</cmd1>
        <cmd2>0xC2</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramEeprom>
      <IspReadFlash>
        <blockSize>256</blockSize>
      </IspReadFlash>
      <IspReadEeprom>
        <blockSize>256</blockSize>
      </IspReadEeprom>
      <IspReadFuse>
        <pollIndex>4</pollIndex>
      </IspReadFuse>
      <IspReadLock>
        <pollIndex>4</pollIndex>
      </IspReadLock>
      <IspReadSign>
        <pollIndex>4</pollIndex>
      </IspReadSign>
      <IspReadOsccal>
        <pollIndex>4</pollIndex>
      </IspReadOsccal>
      <PPControlStack>0x0E 0x1E 0x0F 0x1F 0x2E 0x3E 0x2F 0x3F 0x4E 0x5E 0x4F 0x5F 0x6E 0x7E 0x6F 0x7F 0x66 0x76 0x67 0x77 0x6A 0x7A 0x6B 0x7B 0xBE 0xFD 0x00 0x01 0x00 0x00 0x00 0x00</PPControlStack>
      <PpEnterProgMode>
        <stabDelay>100</stabDelay>
        <progModeDelay>0</progModeDelay>
        <latchCycles>5</latchCycles>
        <toggleVtg>1</toggleVtg>
        <powerOffDelay>15</powerOffDelay>
        <resetDelayMs>1</resetDelayMs>
        <resetDelayUs>0</resetDelayUs>
      </PpEnterProgMode>
      <PpLeaveProgMode>
        <stabDelay>15</stabDelay>
        <resetDelay>15</resetDelay>
      </PpLeaveProgMode>
      <PpChipErase>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpChipErase>
      <PpProgramFlash>
        <pollTimeout>5</pollTimeout>
        <mode>0x0D</mode>
        <blockSize>256</blockSize>
      </PpProgramFlash>
      <PpReadFlash>
        <blockSize>256</blockSize>
      </PpReadFlash>
      <PpProgramEeprom>
        <pollTimeout>5</pollTimeout>
        <mode>0x05</mode>
        <blockSize>256</blockSize>
      </PpProgramEeprom>
      <PpReadEeprom>
        <blockSize>256</blockSize>
      </PpReadEeprom>
      <PpProgramFuse>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramFuse>
      <PpProgramLock>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramLock>
    </STK500_2>
    <STK500_2>
      <IspEnterProgMode>
        <timeout>200</timeout>
        <stabDelay>100</stabDelay>
        <cmdexeDelay>25</cmdexeDelay>
        <synchLoops>32</synchLoops>
        <byteDelay>0</byteDelay>
        <pollIndex>3</pollIndex>
        <pollValue>0x53</pollValue>
      </IspEnterProgMode>
      <IspLeaveProgMode>
        <preDelay>1</preDelay>
        <postDelay>1</postDelay>
      </IspLeaveProgMode>
      <IspChipErase>
        <eraseDelay>45</eraseDelay>
        <pollMethod>1</pollMethod>
      </IspChipErase>
      <IspProgramFlash>
        <mode>0x41</mode>
        <blockSize>64</blockSize>
        <delay>6</delay>
        <cmd1>0x40</cmd1>
        <cmd2>0x4C</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramFlash>
      <IspProgramEeprom>
        <mode>0x41</mode>
        <blockSize>4</blockSize>
        <delay>5</delay>
        <cmd1>0xC1</cmd1>
        <cmd2>0xC2</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramEeprom>
      <IspReadFlash>
        <blockSize>256</blockSize>
      </IspReadFlash>
      <IspReadEeprom>
        <blockSize>256</blockSize>
      </IspReadEeprom>
      <IspReadFuse>
        <pollIndex>4</pollIndex>
      </IspReadFuse>
      <IspReadLock>
        <pollIndex>4</pollIndex>
      </IspReadLock>
      <IspReadSign>
        <pollIndex>4</pollIndex>
      </IspReadSign>
      <IspReadOsccal>
        <pollIndex>4</pollIndex>
      </IspReadOsccal>
      <PPControlStack>0x0E 0x1E 0x0F 0x1F 0x2E 0x3E 0x2F 0x3F 0x4E 0x5E 0x4F 0x5F 0x6E 0x7E 0x6F 0x7F 0x66 0x76 0x67 0x77 0x6A 0x7A 0x6B 0x7B 0xBE 0xFD 0x00 0x01 0x00 0x00 0x00 0x00</PPControlStack>
      <PpEnterProgMode>
        <stabDelay>100</stabDelay>
        <progModeDelay>0</progModeDelay>
        <latchCycles>5</latchCycles>
        <toggleVtg>1</toggleVtg>
        <powerOffDelay>15</powerOffDelay>
        <resetDelayMs>1</resetDelayMs>
        <resetDelayUs>0</resetDelayUs>
      </PpEnterProgMode>
      <PpLeaveProgMode>
        <stabDelay>15</stabDelay>
        <resetDelay>15</resetDelay>
      </PpLeaveProgMode>
      <PpChipErase>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpChipErase>
      <PpProgramFlash>
        <pollTimeout>5</pollTimeout>
        <mode>0x0D</mode>
        <blockSize>256</blockSize>
      </PpProgramFlash>
      <PpReadFlash>
        <blockSize>256</blockSize>
      </PpReadFlash>
      <PpProgramEeprom>
        <pollTimeout>5</pollTimeout>
        <mode>0x05</mode>
        <blockSize>256</blockSize>
      </PpProgramEeprom>
      <PpReadEeprom>
        <blockSize>256</blockSize>
      </PpReadEeprom>
      <PpProgramFuse>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramFuse>
      <PpProgramLock>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramLock>
    </STK500_2>
    <AVRDragon/>
    <AVRISPmkII/>
  </ICE_SETTINGS>
  <V2>
    <templates>
      <module class="FUSE">
        <registers name="FUSE" memspace="FUSE">
          <reg size="1" name="HIGH" offset="0x01">
            <bitfield name="EELOCK" mask="0x80" text="Upper EEPROM Locked (disabled)" icon=""/>
            <bitfield name="DWEN" mask="0x40" text="Debug Wire enable" icon=""/>
            <bitfield name="SPIEN" mask="0x20" text="Serial program downloading (SPI) enabled" icon=""/>
            <bitfield name="WDTON" mask="0x10" text="Watch-dog Timer always on" icon=""/>
            <bitfield name="EESAVE" mask="0x08" text="Preserve EEPROM through the Chip Erase cycle" icon=""/>
            <bitfield name="BOOTSZ" mask="0x06" text="Boot size select" icon="" enum="ENUM_BOOTSZ"/>
            <bitfield name="BOOTRST" mask="0x01" text="Select reset vector" icon=""/>
          </reg>
          <reg size="1" name="LOW" offset="0x00">
            <bitfield name="CKDIV8" mask="0x80" text="Divide clock by 8 internally" icon=""/>
            <bitfield name="CKOUT" mask="0x40" text="Clock output on PORTC1" icon=""/>
            <bitfield name="SUT_CKSEL" mask="0x30" text="Select Clock Source" icon="" enum="ENUM_SUT_CKSEL"/>
            <bitfield name="WDRCON" mask="0x08" text="Enable Watchdog RC-Oscillator" icon=""/>
            <bitfield name="FRCFS" mask="0x04" text="Fast RC-Oscillator Frequency select" icon=""/>
            <bitfield name="BODEN" mask="0x02" text="Enable Brown-out detection" icon=""/>
            <bitfield name="TSRDI" mask="0x01" text="Disable Temperatur shutdown Reset " icon=""/>
          </reg>
        </registers>
        <enumerator name="ENUM_SUT_CKSEL">
          <enum val="0x00" text="Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms;   [SUT=00]" constname="6CK_14CK_0MS"/>
          <enum val="0x01" text="Start-up time PWRDWN/RESET: 6 CK/14 CK + 5.7 ms; [SUT=01]" constname="6CK_14CK"/>
          <enum val="0x02" text="Start-up time PWRDWN/RESET: 6 CK/14 CK + 90 ms;  [SUT=10]" constname="6CK_14CK_0MS"/>
        </enumerator>
        <enumerator name="ENUM_BOOTSZ">
          <enum val="0x03" text="Boot size = 128 words" constname="128W"/>
          <enum val="0x02" text="Boot size = 256 words" constname="256W"/>
          <enum val="0x01" text="Boot size = 512 words" constname="512W"/>
          <enum val="0x00" text="Boot size = 1024 words" constname="1024W"/>
        </enumerator>
      </module>
      <module class="LOCKBIT">
        <registers name="LOCKBIT" memspace="LOCKBIT">
          <reg size="1" name="LOCKBIT" offset="0x00">
            <bitfield name="LB" mask="0x03" text="Memory Lock" icon="" enum="ENUM_LB"/>
            <bitfield name="BLB0" mask="0x0C" text="Boot Loader Protection Mode" icon="" enum="ENUM_BLB"/>
            <bitfield name="BLB1" mask="0x30" text="Boot Loader Protection Mode" icon="" enum="ENUM_BLB2"/>
          </reg>
        </registers>
        <enumerator name="ENUM_LB">
          <enum val="0x00" text="Further programming and verification disabled" constname="PROG_VER_DISABLED"/>
          <enum val="0x02" text="Further programming disabled" constname="PROG_DISABLED"/>
          <enum val="0x03" text="No memory lock features enabled" constname="NO_LOCK"/>
        </enumerator>
        <enumerator name="ENUM_BLB">
          <enum val="0x00" text="LPM and SPM prohibited in Application Section" constname="LPM_SPM_DISABLE"/>
          <enum val="0x01" text="LPM prohibited in Application Section" constname="LPM_DISABLE"/>
          <enum val="0x02" text="SPM prohibited in Application Section" constname="SPM_DISABLE"/>
          <enum val="0x03" text="No lock on SPM and LPM in Application Section" constname="NO_LOCK"/>
        </enumerator>
        <enumerator name="ENUM_BLB2">
          <enum val="0x00" text="LPM and SPM prohibited in Boot Section" constname="LPM_SPM_DISABLE"/>
          <enum val="0x01" text="LPM prohibited in Boot Section" constname="LPM_DISABLE"/>
          <enum val="0x02" text="SPM prohibited in Boot Section" constname="SPM_DISABLE"/>
          <enum val="0x03" text="No lock on SPM and LPM in Boot Section" constname="NO_LOCK"/>
        </enumerator>
      </module>
      <module class="SENSOR_INTERFACE" text="">
        <registers name="SENSOR_INTERFACE" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="MSVCAL" offset="0x67" text="Motion Sensor Voltage Calibration Register" icon="io_analo.bmp" mask="0xFF"/>
          <reg size="1" name="SCR" offset="0x48" text="Sensor Control Register" icon="io_flag.bmp">
            <bitfield name="SMEN" mask="0x08" text="Sensor Motion Enable Bit" icon=""/>
            <bitfield name="SEN" mask="0x06" text="Sensor enable Bits" icon=""/>
            <bitfield name="SMS" mask="0x01" text="Sensor Measurement Start Bit" icon=""/>
          </reg>
          <reg size="1" name="SCCR" offset="0x49" text="Sensor Capacitor Control Register" icon="io_flag.bmp">
            <bitfield name="SCCS" mask="0x1C" text="Sensor Capacitor Channel Select Bit2" icon=""/>
            <bitfield name="SRCC" mask="0x03" text="Sensor Reference Charge Current Bit1" icon=""/>
          </reg>
          <reg size="1" name="SVCR" offset="0x47" text="Sensor Voltage Control Register" icon="io_analo.bmp" mask="0x1F"/>
          <reg size="1" name="SIMSK" offset="0x61" text="Sensor Interrupt Mask register" icon="io_flag.bmp">
            <bitfield name="MSIE" mask="0x01" text="Motion Sensor Interrupt Enable Bit" icon=""/>
          </reg>
          <reg size="1" name="SSFR" offset="0x39" text="Sensor Status + Flag Register" icon="io_flag.bmp">
            <bitfield name="MSENO" mask="0x02" text="Motion Sensor Output" icon=""/>
            <bitfield name="MSENF" mask="0x01" text="Motion Sensor Flag" icon=""/>
          </reg>
          <reg size="1" name="TSCR" offset="0x64" text="Temperature Sensor Control Register" icon="io_flag.bmp">
            <bitfield name="TSSD" mask="0x01" text="Temperature Sensor Shutdown mode Disable" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="SPI" text="">
        <registers name="SPI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="SPDR" offset="0x4E" text="SPI Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="SPSR" offset="0x4D" text="SPI Status Register" icon="io_flag.bmp">
            <bitfield name="SPIF" mask="0x80" text="SPI Interrupt Flag" icon=""/>
            <bitfield name="WCOL" mask="0x40" text="Write Collision Flag" icon=""/>
            <bitfield name="SPI2X" mask="0x01" text="Double SPI Speed Bit" icon=""/>
          </reg>
          <reg size="1" name="SPCR" offset="0x4C" text="SPI Control Register" icon="io_flag.bmp">
            <bitfield name="SPIE" mask="0x80" text="SPI Interrupt Enable" icon=""/>
            <bitfield name="SPE" mask="0x40" text="SPI Enable" icon=""/>
            <bitfield name="DORD" mask="0x20" text="Data Order" icon=""/>
            <bitfield name="MSTR" mask="0x10" text="Master/Slave Select" icon=""/>
            <bitfield name="CPOL" mask="0x08" text="Clock polarity" icon=""/>
            <bitfield name="CPHA" mask="0x04" text="Clock Phase" icon=""/>
            <bitfield name="SPR" mask="0x03" text="SPI Clock Rate Selects" icon="" enum="COMM_SCK_RATE_3BIT"/>
          </reg>
        </registers>
        <enumerator name="COMM_SCK_RATE_3BIT">
          <enum val="0x00" text="fosc/4"/>
          <enum val="0x01" text="fosc/16"/>
          <enum val="0x02" text="fosc/64"/>
          <enum val="0x03" text="fosc/128"/>
          <enum val="0x04" text="fosc/2"/>
          <enum val="0x05" text="fosc/8"/>
          <enum val="0x06" text="fosc/32"/>
          <enum val="0x07" text="fosc/64"/>
        </enumerator>
      </module>
      <module class="CPU" text="">
        <registers name="CPU" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="CLKPR" offset="0x5C" text="Clock Prescaler Register" icon="io_cpu.bmp">
            <bitfield name="CLPCE" mask="0x80" text="Clock Prescaler Change Enable Bit" icon=""/>
            <bitfield name="CLTPS" mask="0x38" text="Clock Timer Prescaler Select Bits" icon=""/>
            <bitfield name="CLKPS" mask="0x07" text="Clock system Prescaler Select Bits" icon=""/>
          </reg>
          <reg size="1" name="CMCR" offset="0x2F" text="Clock Management Control Register" icon="io_cpu.bmp">
            <bitfield name="CMCCE" mask="0x80" text="Clock Management Control Change Enable Bit" icon=""/>
            <bitfield name="ECINS" mask="0x20" text="External Clock Input Select Bit" icon=""/>
            <bitfield name="CCS" mask="0x10" text="Core Clock Select Bit" icon=""/>
            <bitfield name="CMONEN" mask="0x08" text="Clock Monitoring Enable" icon=""/>
            <bitfield name="SRCD" mask="0x04" text="Slow RC-oscillator Disable Bit" icon=""/>
            <bitfield name="CMM" mask="0x03" text="Clock Management Mode Bitss" icon=""/>
          </reg>
          <reg size="1" name="CMSR" offset="0x30" text="Clock Management Status Register" icon="io_cpu.bmp">
            <bitfield name="ECF" mask="0x01" text="External Clock input Flag Bit" icon=""/>
          </reg>
          <reg size="1" name="CMIMR" offset="0x5B" text="Clock Management Interrupt Mask Register" icon="io_cpu.bmp">
            <bitfield name="ECIE" mask="0x01" text="External Clock input Interrupt Enable Bit" icon=""/>
          </reg>
          <reg size="1" name="FRCCAL" offset="0x66" text="FRC-Oscillator Calibration Register" icon="io_cpu.bmp" mask="0x3F"/>
          <reg size="1" name="SRCCAL" offset="0x65" text="SRC-Oscillator Calibration Register" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="VMCSR" offset="0x36" text="Voltage Monitor Control and Status Register" icon="io_cpu.bmp">
            <bitfield name="BODLS" mask="0x80" text="Brown-Out Detection Level Select Bit" icon=""/>
            <bitfield name="BODPD" mask="0x40" text="Brown-Out Detection on Power-Down Bit" icon=""/>
            <bitfield name="VMF" mask="0x20" text="Voltage Monitor Flag" icon=""/>
            <bitfield name="VMIM" mask="0x10" text="Voltage Monitor Interrupt Mask Bit" icon=""/>
            <bitfield name="VMLS" mask="0x0E" text="Voltage Monitor Level Select Bits" icon=""/>
            <bitfield name="VMEN" mask="0x01" text="Voltage Monitor Enable Bit" icon=""/>
          </reg>
          <reg size="1" name="SREG" offset="0x5F" text="Status Register" icon="io_sreg.bmp">
            <bitfield name="I" mask="0x80" text="Global Interrupt Enable" icon=""/>
            <bitfield name="T" mask="0x40" text="Bit Copy Storage" icon=""/>
            <bitfield name="H" mask="0x20" text="Half Carry Flag" icon=""/>
            <bitfield name="S" mask="0x10" text="Sign Bit" icon=""/>
            <bitfield name="V" mask="0x08" text="Two's Complement Overflow Flag" icon=""/>
            <bitfield name="N" mask="0x04" text="Negative Flag" icon=""/>
            <bitfield name="Z" mask="0x02" text="Zero Flag" icon=""/>
            <bitfield name="C" mask="0x01" text="Carry Flag" icon=""/>
          </reg>
          <reg size="2" name="SP" offset="0x5D" text="Stack Pointer " icon="io_sph.bmp" mask="0xFFFF"/>
          <reg size="1" name="SPMCSR" offset="0x57" text="Store Program Memory Control Register" icon="io_cpu.bmp">
            <bitfield name="SPMIE" mask="0x80" text="SPM Interrupt Enable" icon=""/>
            <bitfield name="RWWSB" mask="0x40" text="Read-While-Write Section Busy" icon=""/>
            <bitfield name="RWWSRE" mask="0x10" text="Read-While-Write section read enable" icon=""/>
            <bitfield name="BLBSET" mask="0x08" text="Boot Lock Bit Set" icon=""/>
            <bitfield name="PGWRT" mask="0x04" text="Page Write" icon=""/>
            <bitfield name="PGERS" mask="0x02" text="Page Erase" icon=""/>
            <bitfield name="SELFPRGEN" mask="0x01" text="Self Programming Enable" icon=""/>
          </reg>
          <reg size="1" name="MCUCR" offset="0x55" text="MCU Control Register" icon="io_flag.bmp">
            <bitfield name="PUD" mask="0x10" text="" icon=""/>
            <bitfield name="IVSEL" mask="0x02" text="Interrupt Vector Select" icon=""/>
            <bitfield name="IVCE" mask="0x01" text="Interrupt Vector Change Enable" icon=""/>
          </reg>
          <reg size="1" name="MCUSR" offset="0x54" text="MCU Status Register" icon="io_flag.bmp">
            <bitfield name="TSRF" mask="0x20" text="Temperature Shutdown Reset Flag" icon=""/>
            <bitfield name="WDRF" mask="0x08" text="Watchdog Reset Flag" icon=""/>
            <bitfield name="BORF" mask="0x04" text="Brown-out Reset Flag" icon=""/>
            <bitfield name="EXTRF" mask="0x02" text="External Reset Flag" icon=""/>
            <bitfield name="PORF" mask="0x01" text="Power-on reset flag" icon=""/>
          </reg>
          <reg size="1" name="SMCR" offset="0x53" text="Sleep Mode Control Register" icon="io_flag.bmp">
            <bitfield name="SM" mask="0x0E" text="" icon=""/>
            <bitfield name="SE" mask="0x01" text="" icon=""/>
          </reg>
          <reg size="1" name="GPIOR2" offset="0x4B" text="General Purpose I/O Register 2" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="GPIOR1" offset="0x4A" text="General Purpose I/O Register 1" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="GPIOR0" offset="0x3E" text="General Purpose I/O Register 0" icon="io_flag.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="LFRX" text="">
        <registers name="LFRX" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="LFRCR" offset="0x82" text="Low Frequency Receiver Control Register" icon="register.bmp">
            <bitfield name="LFCS" mask="0xE0" text="LF receiver Capacitor Select Bits" icon=""/>
            <bitfield name="LFRSS" mask="0x10" text="LF Receiver Sensitivity Select Bit" icon=""/>
            <bitfield name="LFWM" mask="0x0C" text="LF receiver Wake-up Mode Bits" icon=""/>
            <bitfield name="LFBM" mask="0x02" text="LF receiver Burst Mode enable Bit" icon=""/>
            <bitfield name="LFEN" mask="0x01" text="LF receiver Enable Bit" icon=""/>
          </reg>
          <reg size="1" name="LFCDR" offset="0x52" text="LF receiver Control und Data Register" icon="register.bmp">
            <bitfield name="LFSCE" mask="0x80" text="LF receiver RSSI Software Capture Enable Bit" icon=""/>
            <bitfield name="LFRST" mask="0x40" text="LF receiver Reset Bit" icon=""/>
            <bitfield name="LFDO" mask="0x01" text="LF receiver Data Output Bit" icon=""/>
          </reg>
          <reg size="1" name="LFRB" offset="0x56" text="Low Frequency Receive data Buffer" icon="register.bmp" mask="0xFF"/>
          <reg size="1" name="LFRR" offset="0x50" text="LF RSSI Data Register" icon="register.bmp" mask="0x7F"/>
          <reg size="1" name="LFHCR" offset="0x83" text="LF Header Compare Register" icon="register.bmp" mask="0x7F"/>
          <reg size="2" name="LFIDC" offset="0x84" text="LF ID Compare Register " icon="register.bmp" mask="0xFFFF"/>
          <reg size="1" name="LFIMR" offset="0x81" text="Low Frequency Interrupt Mask Register" icon="register.bmp">
            <bitfield name="LFEIM" mask="0x04" text="LF receiver End of data Interrupt Mask bit" icon=""/>
            <bitfield name="LFBIM" mask="0x02" text="LF receiver data Buffer Interrupt Mask bit" icon=""/>
            <bitfield name="LFWIM" mask="0x01" text="LF receiver Wake-up Interrupt Mask bit" icon=""/>
          </reg>
          <reg size="1" name="LFFR" offset="0x38" text="Low Frequency Flag Register" icon="io_flag.bmp">
            <bitfield name="LFRF" mask="0x08" text="LF receiver Rssi data Flag" icon=""/>
            <bitfield name="LFEDF" mask="0x04" text="LF receiver End of data Flag" icon=""/>
            <bitfield name="LFBF" mask="0x02" text="LF receiver data Buffer full Flag" icon=""/>
            <bitfield name="LFWPF" mask="0x01" text="LF receiver Wake-up Flag" icon=""/>
          </reg>
          <reg size="2" name="LFCAL" offset="0x86" text="LF Calibration Register  Bytes" icon="io_flag.bmp" mask="0xFFFF"/>
        </registers>
      </module>
      <module class="EXTERNAL_INTERRUPT" text="">
        <registers name="EXTERNAL_INTERRUPT" memspace="DATAMEM" text="" icon="io_ext.bmp">
          <reg size="1" name="EICRA" offset="0x69" text="External Interrupt Control Register" icon="io_flag.bmp">
            <bitfield name="ISC1" mask="0x0C" text="External Interrupt Sense Control 1 Bits" icon=""/>
            <bitfield name="ISC0" mask="0x03" text="External Interrupt Sense Control 0 Bits" icon=""/>
          </reg>
          <reg size="1" name="EIMSK" offset="0x44" text="External Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="INT" mask="0x03" text="External Interrupt Request 1 Enable" icon=""/>
          </reg>
          <reg size="1" name="EIFR" offset="0x3D" text="External Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="INTF" mask="0x03" text="External Interrupt Flags" icon=""/>
          </reg>
          <reg size="1" name="PCMSK0" offset="0x6A" text="Pin Change Mask Register 0" icon="io_flag.bmp">
            <bitfield name="PCINT" mask="0xFF" text="Pin Change Enable Masks" icon=""/>
          </reg>
          <reg size="1" name="PCMSK1" offset="0x6B" text="Pin Change Mask Register 1" icon="io_flag.bmp">
            <bitfield name="PCINT" mask="0x07" text="Pin Change Enable Masks" icon="" lsb="8"/>
          </reg>
          <reg size="1" name="PCMSK2" offset="0x6C" text="Pin Change Mask Register 2" icon="io_flag.bmp">
            <bitfield name="PCINT" mask="0xFF" text="Pin Change Enable Masks" icon="" lsb="16"/>
          </reg>
          <reg size="1" name="PCIFR" offset="0x37" text="Pin Change Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="PCIF" mask="0x07" text="Pin Change Interrupt Flags" icon=""/>
          </reg>
          <reg size="1" name="PCICR" offset="0x43" text="Pin Change Interrupt Control Register" icon="io_cpu.bmp">
            <bitfield name="PCIE" mask="0x07" text="Pin Change Interrupt Enables" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="PORTB" text="">
        <registers name="PORTB" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTB" offset="0x25" text="Port B Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRB" offset="0x24" text="Port B Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINB" offset="0x23" text="Port B Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTD" text="">
        <registers name="PORTD" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTD" offset="0x2B" text="Port D Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRD" offset="0x2A" text="Port D Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PIND" offset="0x29" text="Port D Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="TIMER_COUNTER_1" text="">
        <registers name="TIMER_COUNTER_1" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="T1CR" offset="0x58" text="Timer 1 Control Register" icon="io_timer.bmp">
            <bitfield name="T1IE" mask="0x80" text="Timer 1 Interrupt Enable Bit" icon=""/>
            <bitfield name="T1CS" mask="0x38" text="Timer 1 Clock Select Bits" icon=""/>
            <bitfield name="T1PS" mask="0x07" text="Timer 1 Prescaler Select Bits" icon=""/>
          </reg>
          <reg size="1" name="T10IFR" offset="0x3A" text="Timer1/0 Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="T1F" mask="0x02" text="Timer 1 Flag Bit" icon=""/>
            <bitfield name="T0F" mask="0x01" text="Timer 0 Flag Bit" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="TIMER_COUNTER_2" text="">
        <registers name="TIMER_COUNTER_2" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="T2CRA" offset="0x31" text="Timer 2 Control Register A" icon="io_flag.bmp">
            <bitfield name="T2E" mask="0x80" text="Timer 2 Enable Bit" icon=""/>
            <bitfield name="T2TS" mask="0x40" text="Timer 2 Toggle with Start Bit" icon=""/>
            <bitfield name="T2ICS" mask="0x20" text="Timer Input Capture Select Bit" icon=""/>
            <bitfield name="T2CRM" mask="0x08" text="Timer 2 Compare Reset Mask Bit" icon=""/>
            <bitfield name="T2CR" mask="0x04" text="Timer2 Counter Reset" icon=""/>
            <bitfield name="T2CTM" mask="0x02" text="Timer 2 Compare Toggle Mask Bit" icon=""/>
            <bitfield name="T2OTM" mask="0x01" text="Timer 2 Overflow Toggle Mask Bit" icon=""/>
          </reg>
          <reg size="1" name="T2CRB" offset="0x32" text="Timer 2 Control Register B" icon="io_flag.bmp">
            <bitfield name="T2SCE" mask="0x01" text="Timer 2 Software Capture Enable Bit" icon=""/>
          </reg>
          <reg size="1" name="T2MDR" offset="0x4F" text="Timer 2 Modulator Data Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="T2ICR" offset="0x6F" text="Timer 2 Input Capture Register High Byte" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="T2ICRL" offset="0x6E" text="Timer 2 Input Capture Register Low Byte" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="2" name="T2COR" offset="0x70" text="Timer2 Compare Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="1" name="T2IFR" offset="0x3B" text="Timer2 Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="T2TCF" mask="0x20" text="Timer2 SSI Transmit Complete Flag Bit" icon=""/>
            <bitfield name="T2TXF" mask="0x10" text="Timer2 SSI Transmit Flag Bit" icon=""/>
            <bitfield name="T2RXF" mask="0x08" text="Timer2 SSI Receive Flag Bit" icon=""/>
            <bitfield name="T2ICF" mask="0x04" text="Timer2 Input Capture Flag Bit" icon=""/>
            <bitfield name="T2COF" mask="0x02" text="Timer 2 Compare Flag Bit" icon=""/>
            <bitfield name="T2OFF" mask="0x01" text="Timer 2 Overflow Flag Bit" icon=""/>
          </reg>
          <reg size="1" name="T2IMR" offset="0x74" text="Timer 2 Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="T2TCIM" mask="0x20" text="Timer2 SSI Transmit Complete Interrupt Mask Bit" icon=""/>
            <bitfield name="T2TXIM" mask="0x10" text="Timer2 SSI Transmit Interrupt Mask Bit" icon=""/>
            <bitfield name="T2RXIM" mask="0x08" text="Timer2 SSI Receive Interrupt Mask Bit" icon=""/>
            <bitfield name="T2CPIM" mask="0x04" text="Timer 2 Capture Interrupt Mask Bit" icon=""/>
            <bitfield name="T2CIM" mask="0x02" text="Timer 2 Compare Interrupt Mask Bit" icon=""/>
            <bitfield name="T2OIM" mask="0x01" text="Timer 2 Overflow Interrupt Mask Bit" icon=""/>
          </reg>
          <reg size="1" name="T2MRA" offset="0x72" text="Timer 2 Mode Register A" icon="io_flag.bmp">
            <bitfield name="T2TP" mask="0xC0" text="Timer 2 Top select Bits" icon=""/>
            <bitfield name="T2CNC" mask="0x20" text="Timer 2 Input Capture Noise Canceler Bit" icon=""/>
            <bitfield name="T2CE" mask="0x18" text="Timer 2 Capture Edge Select Bits" icon=""/>
            <bitfield name="T2CS" mask="0x07" text="Timer 2 Clock Select Bits" icon=""/>
          </reg>
          <reg size="1" name="T2MRB" offset="0x73" text="Timer 2 Mode Register B" icon="io_flag.bmp">
            <bitfield name="T2SSIE" mask="0x80" text="Timer 2 SSI Enable Bit" icon=""/>
            <bitfield name="T2CPOL" mask="0x40" text="Timer2 Clock Polarity for SSI shift clock" icon=""/>
            <bitfield name="T2TOP" mask="0x10" text="Timer 2 Toggle Output Preset Bit" icon=""/>
            <bitfield name="T2M" mask="0x0F" text="Timer 2 Mode Bits" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="TIMER_COUNTER_3" text="">
        <registers name="TIMER_COUNTER_3" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="T3CRA" offset="0x34" text="Timer 3 Control Register A" icon="io_flag.bmp">
            <bitfield name="T3E" mask="0x80" text="Timer 3 Enable Bit" icon=""/>
            <bitfield name="T3TS" mask="0x40" text="Timer 3 Toggle with Start Bit" icon=""/>
            <bitfield name="T3CR" mask="0x04" text="Timer3 Counter Reset" icon=""/>
            <bitfield name="T3SCE" mask="0x02" text="Timer 3 Software Capture Enable Bit" icon=""/>
            <bitfield name="T3AC" mask="0x01" text="Timer 3 Alternate Compare register sequence bit" icon=""/>
          </reg>
          <reg size="1" name="T3CRB" offset="0x7E" text="Timer 3 Control Register B" icon="io_flag.bmp">
            <bitfield name="T3CPRM" mask="0x40" text="Timer 3 CaPture Reset Mask bit" icon=""/>
            <bitfield name="T3CRMB" mask="0x20" text="Timer 3 Compare Reset Mask bit B" icon=""/>
            <bitfield name="T3SAMB" mask="0x10" text="Timer 3 Single Action Mask bit B" icon=""/>
            <bitfield name="T3CTMB" mask="0x08" text="Timer 3 Compare Toggle Mask bit B" icon=""/>
            <bitfield name="T3CRMA" mask="0x04" text="Timer 3 Compare Reset Mask bit A" icon=""/>
            <bitfield name="T3SAMA" mask="0x02" text="Timer 3 Single Action Mask bit A" icon=""/>
            <bitfield name="T3CTMA" mask="0x01" text="Timer 3 Compare Toggle Mask bit A" icon=""/>
          </reg>
          <reg size="1" name="T3MRA" offset="0x7C" text="Timer 3 Mode Register A" icon="io_timer.bmp">
            <bitfield name="T3ICS" mask="0xC0" text="Timer 3 Input Capture Select Bits" icon=""/>
            <bitfield name="T3CNC" mask="0x20" text="Timer 3 input Capture Noise Canceler Bit" icon=""/>
            <bitfield name="T3CE" mask="0x18" text="Timer 3 Capture Edge select Bits" icon=""/>
            <bitfield name="T3CS" mask="0x07" text="Timer 3 Clock Select Bits" icon=""/>
          </reg>
          <reg size="1" name="T3IFR" offset="0x3C" text="Timer3 Interrupt Flag Register" icon="io_timer.bmp">
            <bitfield name="T3ICF" mask="0x08" text="Timer3 Input Capture Flag bit" icon=""/>
            <bitfield name="T3COBF" mask="0x04" text="Timer3 Compare B Flag bit" icon=""/>
            <bitfield name="T3COAF" mask="0x02" text="Timer3 Compare A Flag bit" icon=""/>
            <bitfield name="T3OFF" mask="0x01" text="Timer3 OverFlow Flag bit" icon=""/>
          </reg>
          <reg size="1" name="T3IMR" offset="0x7F" text="Timer3 Interrupt Mask Register" icon="io_timer.bmp">
            <bitfield name="T3CPIM" mask="0x08" text="Timer3 Capture Interrupt Mask bit" icon=""/>
            <bitfield name="T3CBIM" mask="0x04" text="Timer3 Compare B Interrupt Mask bit" icon=""/>
            <bitfield name="T3CAIM" mask="0x02" text="Timer3 Compare A Interrupt Mask bit" icon=""/>
            <bitfield name="T3OIM" mask="0x01" text="Timer3 Overflow Interrupt Mask bit" icon=""/>
          </reg>
          <reg size="1" name="T3MRB" offset="0x7D" text="Timer 3 Mode Register B" icon="io_timer.bmp">
            <bitfield name="T3TOP" mask="0x10" text="Timer 3 Toggle Output Preset Bit" icon=""/>
            <bitfield name="T3M" mask="0x07" text="Timer 3 Mode Bits" icon=""/>
          </reg>
          <reg size="2" name="T3ICR" offset="0x76" text="Timer3 Input Capture Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="T3CORA" offset="0x78" text="Timer3 COmpare Register A  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="T3CORB" offset="0x7A" text="Timer3 COmpare Register B  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
        </registers>
      </module>
      <module class="WATCHDOG" text="">
        <registers name="WATCHDOG" memspace="DATAMEM" text="" icon="io_watch.bmp">
          <reg size="1" name="WDTCR" offset="0x60" text="Watchdog Timer Control Register" icon="io_flag.bmp">
            <bitfield name="WDCE" mask="0x10" text="Watchdog Change Enable" icon=""/>
            <bitfield name="WDE" mask="0x08" text="Watch Dog Enable" icon=""/>
            <bitfield name="WDPS" mask="0x07" text="Watch Dog Timer Prescaler Select bits" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="TIMER_COUNTER_0" text="">
        <registers name="TIMER_COUNTER_0" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="T0CR" offset="0x59" text="Timer 0 Control Register" icon="io_timer.bmp">
            <bitfield name="T0PBS" mask="0xE0" text="Timer 0 Prescaler B Select Bits" icon=""/>
            <bitfield name="T0PR" mask="0x10" text="Timer 0 Prescaler Reset Bit" icon=""/>
            <bitfield name="T0IE" mask="0x08" text="Timer 0 Interrupt Enable Bit" icon=""/>
            <bitfield name="T0PAS" mask="0x07" text="Timer 0 Prescaler A Select Bits" icon=""/>
          </reg>
          <reg size="1" name="T10IFR" offset="0x3A" text="Timer1/0 Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="T1F" mask="0x02" text="Timer 1 Flag Bit" icon=""/>
            <bitfield name="T0F" mask="0x01" text="Timer 0 Flag Bit" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="EEPROM" text="">
        <registers name="EEPROM" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="2" name="EEAR" offset="0x41" text="EEPROM Address Register  Bytes" icon="io_cpu.bmp" mask="0x01FF"/>
          <reg size="1" name="EEDR" offset="0x40" text="EEPROM Data Register" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="EECR" offset="0x3F" text="EEPROM Control Register" icon="io_flag.bmp">
            <bitfield name="EEPM" mask="0x30" text="EEPROM Programming Mode Bits" icon=""/>
            <bitfield name="EERIE" mask="0x08" text="EEPROM Ready Interrupt Enable" icon=""/>
            <bitfield name="EEMWE" mask="0x04" text="EEPROM Master Write Enable" icon=""/>
            <bitfield name="EEWE" mask="0x02" text="EEPROM Write Enable" icon=""/>
            <bitfield name="EERE" mask="0x01" text="EEPROM Read Enable" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="PORTC" text="">
        <registers name="PORTC" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTC" offset="0x28" text="Port C Data Register" icon="io_port.bmp" mask="0x07"/>
          <reg size="1" name="DDRC" offset="0x27" text="Port C Data Direction Register" icon="io_flag.bmp" mask="0x07"/>
          <reg size="1" name="PINC" offset="0x26" text="Port C Input Pins" icon="io_port.bmp" mask="0x07"/>
        </registers>
      </module>
    </templates>
    <modules>
      <module implements="SENSOR_INTERFACE" name="SENSOR_INTERFACE">
        <registers implements="SENSOR_INTERFACE" name="SENSOR_INTERFACE" offset="0x00" text=""/>
      </module>
      <module implements="SPI" name="SPI">
        <registers implements="SPI" name="SPI" offset="0x00" text=""/>
      </module>
      <module implements="CPU" name="CPU">
        <registers implements="CPU" name="CPU" offset="0x00" text=""/>
      </module>
      <module implements="LFRX" name="LFRX">
        <registers implements="LFRX" name="LFRX" offset="0x00" text=""/>
      </module>
      <module implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT">
        <registers implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT" offset="0x00" text=""/>
      </module>
      <module implements="PORTB" name="PORTB">
        <registers implements="PORTB" name="PORTB" offset="0x00" text=""/>
      </module>
      <module implements="PORTD" name="PORTD">
        <registers implements="PORTD" name="PORTD" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1">
        <registers implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_2" name="TIMER_COUNTER_2">
        <registers implements="TIMER_COUNTER_2" name="TIMER_COUNTER_2" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_3" name="TIMER_COUNTER_3">
        <registers implements="TIMER_COUNTER_3" name="TIMER_COUNTER_3" offset="0x00" text=""/>
      </module>
      <module implements="WATCHDOG" name="WATCHDOG">
        <registers implements="WATCHDOG" name="WATCHDOG" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0">
        <registers implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0" offset="0x00" text=""/>
      </module>
      <module implements="EEPROM" name="EEPROM">
        <registers implements="EEPROM" name="EEPROM" offset="0x00" text=""/>
      </module>
      <module implements="PORTC" name="PORTC">
        <registers implements="PORTC" name="PORTC" offset="0x00" text=""/>
      </module>
    </modules>
    <fuses>
      <fuse implements="FUSE" name="FUSE">
        <registers implements="FUSE" name="FUSE"/>
      </fuse>
    </fuses>
    <lockbits>
      <lockbit implements="LOCKBIT" name="LOCKBIT">
        <registers implements="LOCKBIT" name="LOCKBIT"/>
      </lockbit>
    </lockbits>
  </V2>
</AVRPART>
